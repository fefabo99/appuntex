\documentclass[12pt, a4paper, openany]{book}
\usepackage{fstyle}

\begin{document}
\title{Preparazione all'esame di Analisi e Progetto di Algoritmi}
\author{Fabio Ferrario}
\date{2022}
\maketitle
\tableofcontents

\chapter{Come si risolvono gli esercizi}
\section{Introduzione}
All'esame di Analisi e Progetto di Algoritmi vengono (generalmente) proposti degli esercizi che ti richiedono di scrivere delle varianti di alcuni algoritmi.
Per risolvere questi esercizi bisogna innanzitutto \emph{sapere bene gli algoritmi di cui bisogna fare le varianti}.
Questi generalmente sono:
\begin{itemize}
	\item Algoritmo di Floyd-Warshall
	\item Algoritmi BFS e DFS
	\item Algoritmo LCS
	\item Raramente Algorimto di Dijkstra
\end{itemize}
Se conoscete bene questi algoritmi vi basterà conoscere i procedimenti che riporto qua sotto per poter risolvere (bene o male) ogni tipo di esercizio.

\section{Varianti di FW}
Un possibile tipo di esercizio d'esame è problema in cui is chiede di creare un algoritmo di programmazione dinamica
che, dato un grafo pesato e una funzione che associa un numero o un colore a ogni arco o vertice, stabilisce {il peso di}/{se seiste} un cammino minimo da $i$ a $j$
che rispetti alcuni vincoli.

\paragraph{Il procedimento}è sostanzialmente sempre lo stesso, bisogna trovare un sottoproblema $k$-esimo e capire se le informazioni date da i vertici $(i,k)$ e $(k,j)$
sono sufficienti a risolvere il problema. in caso contrario bisogna definire un problema ausiliario.

\subparagraph{Variabili associate} del sottoproblema (quindi quelle introdotto) sono sempre: il matricione $D^k$ in cui $d^k_{ij}$ è il peso/l'esistenza del cammino da i a j
i cui vertici intermedi appartengono a $\{1,...,k\}$

\subparagraph{soluzione del sottoproblema}
Se le informazioni sono sufficienti, si formano le due equazioni di ricorrenza in cui si calcola $d^k_{ij}$, per il caso base e per il Passo Ricorsivo.
\\Il passo ricorsivo (k>0) è sempre diviso in due casi ipotetici (sibilla cumana), il caso in cui k NON fa parte del cammino minimo, in cui il valore di $d^k_{ij}$ diventerà
il valore del cammino ij escludendo k come cammino intermedio, quindi k-1.\\Oppure il caso in cui k fa parte del cammino minimo, in cui il valore di $d^k_{ij}$ diventerà la somma (oppure l'AND) dei valori dei cammini ik e kj (tutti e due escludendo k come cammino intermedio)
\\L'equazione di ricorrenza diventerà quindi il minimo dei due casi (oppure un OR nel caso in cui si voglia verificare l'esistenza).\\
Il caso base invece è dove i calcoli veri vengono fatti. in genere il valore di $d^k_{ij}$ ha tre possibilità: se i=j assumerà 0 o TRUE, perchè se i e j coincidono vuol dire che non ci sono archi per passare da uno all'altro.
Se i e j non coincidono, il loro cammino è compreso in E e sono rispettate le condizioni del problema allora $d^k_{ij}$ diventerà il peso del cammino (oppure TRUE). Diventa sempre $\infty$ o FALSE altrimenti.


\subparagraph{Problema ausiliario} Nel caso in cui non sia possibile calcolare il risultato con le informazioni date è necessario introdurre un Problema ausiliario.
Questo problema generalmente è lo stesso iniziale ma aggiunge un controllo aggiuntivo, per esempio sul primo arco uscente e l'ultimo entrante del cammino.
Una volta introdotto il problema ausiliario si procede come se fosse un problema normale, quindi si introduce il sottoproblema, le variabili e le equazioni di ricorrenza.
Con le equazioni di ricorrenza però vengono aggiunte delle condizioni particolari che dipendono caso per caso (guarda esercizi).

\subparagraph{Solzuone del problema} La soluzone del problema nel caso in cui non ci sia un problema ausiliario è semplicemente formata da i valori nel matricione introdotto dal sottoproblema (D),
se invece è presente un problema ausiliario, allora la soluzione diventa il minimo (o OR) di tutte le soluzioni del Problema ausiliario

\section{Varianti DFS}
Questo è un generico esercizio del tipo "conta i vertici $\forall$ Componente Connessa di un grafo"

\subsection*{Spiegazione}
è una modifica di DFS in cui DFS-VISIT ritorna il numero di vertici che ha trovato nella componente connessa
del nodo in esame. Quindi dopo ongi chiamata di DFS-VISIT, DFS si ritrova con il numero dei vertici e può farci quello che vuole.
DFS-VISIT funziona come di norma (senza usare i padri che non servono) ma inizializza un contatore (che poi ritornerà) e ogni volta
che fa una chiamata ricorsiva aggiorna il valore.

\subsection*{Pseudocodice}

\begin{lstlisting}[mathescape=true]
DFS_COUNT(G)
    for ogni $u \in V$
        col[u] = WHITE
    for ogni $u \in V$
        if col[u] == WHITE
            num_in_cc = DFS_VISIT_COUNT(u)
            //Qui fai quello che vuoi con num_in_cc 
\end{lstlisting}

\begin{lstlisting}[mathescape=true]
DFS_VISIT_COUNT(u)
    col[u] = GRAY
    count = 0
    for ogni $v \in adj[u]$
        if col[v] == WHITE
            count = count + DFS_VISIT_COUNT(v)
    col[u] = BLACK
    RETURN count + 1
\end{lstlisting}

\chapter{Esercizi d'esame}

\section{FW: Esattamente 3 vertici BLU} Es 2 esame 2017\\
Grafo G dove ad ogni vertice è associato un colore {R,V,B}. Stabilire per ogni coppia di vertici se esiste un cammino con esattamente 3 vertici blu

\paragraph*{Problema ausiliario} Anche se non l'ho scritto in questo esercizio viene introdotto un problema ausiliario, quello in cui il cammino ha esattamente $b$ vertici blu.
\subsection*{Variabili Introdotte}
$D^{n,b}$ Matrice $|V|\cdot|V|$\\
$d^{(k,b)}_{ij}$ = True se esiste un cammino da $i$ a $j$ con esattamente $b$ vertici BLU con vertici intermedi appartenenti a $\{1,..,k\}$.\\
con $b = \{0,...,3\}$ e $k=\{0,...,|V|\}$

\subsection*{Caso Base} k=0\\
Tre casi, con $b \in \{0,1,2\}$ perchè $b < k+2$ siccome con 0 vertici intermedi il cammino $(i,j)$ ha al più due vertici

\begin{equation*}
	d_{ij}^{(0,0)} = \begin{cases}
		TRUE  & i=j\land col(i)\neq B\land col(j)\neq B                      \\
		TRUE  & i\neq j\land (i,j)\in E \land col(i)\neq B\land col(j)\neq B \\
		FALSE & \text{Altrimenti}
	\end{cases}
\end{equation*}

\begin{equation*}
	d_{ij}^{(0,1)} = \begin{cases}
		TRUE  & i=j\land col(i)= col(j) = B                          \\
		TRUE  & i\neq j\land (i,j)\in E \land col(i)= B XOR col(j)=B \\
		FALSE & \text{Altrimenti}
	\end{cases}
\end{equation*}

\begin{equation*}
	d_{ij}^{(0,2)} = \begin{cases}
		TRUE  & i\neq j\land (i,j)\in E \land col(i)= col(j)= B \\
		FALSE & \text{Altrimenti}
	\end{cases}
\end{equation*}

\subsection*{Passo ricorsivo}
Se $k \notin cammino$ allora
\begin{equation*}
	d_{ij}^{(k,b)} = d_{ij}^{(k-1,b)}
\end{equation*}
che per comodità chiameremo $e1$

Se $k \in cammino$ allora dobbiamo distinguere due casi:
\paragraph{$col(k) \neq B$}
\begin{equation*}
	d_{ij}^{(k,b)} = d_{ik}^{(k-1,b_1)} \land d_{kj}^{(k-1,b_2)}
\end{equation*}
in cui $b_1 + b_2 == b$, che per comodità chiameremo $e2_b$
\paragraph{$col(k) \neq B$}
\begin{equation*}
	d_{ij}^{(k,b)} = d_{ik}^{(k-1,b_1)} \land d_{kj}^{(k-1,b_2)}
\end{equation*}
in cui $b_1 + b_2 == b+1$, che per comodità chiameremo $e2_a$

Quindi l'equazione del passo ricorsivo è:
\begin{equation*}
	d^{(k,b)}_{ij} = \begin{cases}
		e1 \lor e2_b & k=B     \\
		e1 \lor e2_a & k\neq B
	\end{cases}
\end{equation*}

\subsection*{Soluzione del problema}
La soluzione del Problema è contenuta in tutti i valori di $D^{|V|,3}$

\section{Cammino minimo vertici con segno alternato} Esercizio 1 esame 12/09/2016\\
Sia A l'insieme dei numeri interi escluso 0.\\
Dato un grafo non orientato (V,E,f) in cui ad ogni vertice è associato un numero intero
diverso da zero (mediante la funzione $f: V\rightarrow A$), mediante la tecnica della
programmazione dinamica si vuole stabilire per ogni coppia di vertici $(i,j)$, se esiste un
cammino da i a j avente vertici che danno luogo ad una alternanza del segno dei numeri
ad esso associati. RISPONDERE PER PUNTI alle seguenti richieste:
\begin{enumerate}
	\item Esplicitare e definire le variabili che servono per risolvere il problema
	\item Scrivere l'equazione di ricorrenza per il CASO BASE, giustificando perché è fatta in quel modo
	\item scrivere la/le equazione/i di ricorrenza per il PASSO RICORSIVO, giustificando perché è/sono fatta/e in quel modo
	\item Scrivere qualè la soluzione del problema, espressa rispetto alle variabili introdotte
\end{enumerate}

\subsection*{Variabili introdotte}
$D^k$ matrice $|V|\cdot|V|$
\\$d^k_{i,j}$ True sse esiste un cammino da $i$ a $j$ che da luogo ad una alternanza di segno usando ${1,...,k}$ vertici intermedi

	\subsection*{Caso Base} Non ci sono vertici intermedi $k=0$
	\begin{equation*}
		d^0_{i,j} = \begin{cases}
			TRUE  & \text{se $i=j$}                                                  \\
			TRUE  & \text{se $i\neq j \land (i,j) \in E \land f(i) \cdot f(j) < 0 $} \\
			FALSE & \text{altrimenti}
		\end{cases}
	\end{equation*}

	\subsection*{Passo Ricorsivo} $k>0$\\
	due casi:
	\begin{itemize}
		\item $k\notin$ cammino $\rightarrow d^k_{ij} = d^{k-1}_{ij}$
		\item $k \in$ cammino $\rightarrow d^k_{ij} = d^{k-1}_{ik} \land d^{k-1}_{kj}$
	\end{itemize}
	Quindi, nel passo ricorsivo con $k>0$:
	\begin{equation*}
		d^k_{ij} = d^{k-1}_{ij} \lor  (d^{k-1}_{ik} \land d^{k-1}_{kj})
	\end{equation*}

	\subsection*{Soluzione del problema}
	La soluzione del problema è costituita da tutti i valori contenuti in $D^{|V|}$

	\section{Esercizio Arco RED mai seguito da arco BLUE}
	Dato un grafo G(V,E,W) orientato e senza cappi in cui ad ogni arco è associato un colore tramite la funzione $col: E\rightarrow \{red,blue\}$
	calcolare $\forall (i,j) \in V^2$ il peso di un cammino minimo da i a j nella quale un arco $red$ non è mai seguito da un arco $blue$

	\paragraph{Definiamo il Problema Ausiliario $P'$}
	Dato $G \forall(a,b) \in C^2$ calcolare $\forall(i,j) \in V^2$ il peso di un cammino minimo da i a j con
	colore del $I$ arco pari ad $a$ e dell'iltimo a $b$

	\paragraph{Sottoproblema $k$esimo di $P'$} con $k \in \{0,...,n\}$
$\forall(a,b) \in C^2$ calcolare $\forall(i,j) \in V^2$ il peso di un cammino minimo da i a j con
	colore del $I$ arco pari ad $a$ e dell'iltimo a $b$ e con vertici intermedi $\in \{0,...,k\}$\\
	\subparagraph{Introduco la variabile $D*{(k,a,b)}$}
$\forall(i,j)\in V^2$ , $d^{(k,a,b)_{ij}}$ è il peso di un cammino minimo da i a j  con
	colore del $I$ arco pari ad $a$ e dell'iltimo a $b$ e con vertici intermedi $\in \{0,...,k\}$\\
	Introduco la variabile $D*{(k,a,b)}$
	\subparagraph{Caso Base sottoproblema di $P'$} $k = 0$

	\begin{equation*}
		d^{(0,a,b)}_{ij} \begin{cases}
			\infty & \text{se $i=j$}                                             \\
			w_{ij} & \text{se $i\neq j \land (i,j)\in E \land col(i,j) = a = b$} \\
			\infty & \text{altrimenti}
		\end{cases}
	\end{equation*}

	\subparagraph{Passo ricorsivo sottoproblema di $P'$} $k > 0$\\
	Abbiamo due casi\\
	se $k \notin cammino$ allora $d^{(k,a,b)}_{ij} = d^{(k-1,a,b)}_{ij}$\\
	se $k \in cammino$ allora \\
	grafo: i [a]- - -[c] k [d]- - -[b] j con $(c,d) \neq (red,blue)$
	tradotto: Se k appartiene al cammino minimo, allora il colore dell'ultimo arco entrante in k deve essere diverso da red, oppure il colore del primo arco uscente da k deve essere diverso da blue.
	quindi: $d^{(k,a,b)}_{ij} = d^{(k-1,a,c}_{ik} + d^{(k-1,d,b}_{kj}$ con $c,d \in C^2$ tc $c\neq red \vee b\neq blue$
	Quindi l'equazione di ricorrenza del passo ricorsivo è:\\
$d^{(k,a,b)}_{ij} = min\{d^{(k-1,a,b)}_{ij} ,d^{(k-1,a,c}_{ik} + d^{(k-1,d,b}_{kj}\}$ con $c,d \in C^2$ tc $c\neq red \vee b\neq blue$

	\subparagraph{Soluzione Problema Ausiliario $P'$} è formata dalle matrici:\\
$D^{(n,red,red)}$ $D^{(n,red,blu)}$ $D^{(n,blu,red)}$ $D^{(n,blu,blu)}$ \\
	Ovvero tutte le combinazioni possibili di cammini minimi con gli archi a e b = red or blu

	\paragraph{Soluzione Problema di partenza $PB$}
	\begin{equation*}
		d^{prob}_{ij} = \begin{cases}
			0                                             & \text{se $i=j$}   \\
			min\{d^{(n,a,b)}_{ij} \forall (a,b) \in C^2\} & \text{altrimenti}
		\end{cases}
	\end{equation*}

	\section{Esercizio k alberi e almeno h vertici} Esercizio 2 esame 12/09/2016\\
	Scrivere un algoritmo che, dati un grafo non orientato e due interi positivi $h>0$ e $k>0$, stabilisce se ENTRAMBE le seguenti condizioni sono verificate
	\begin{itemize}
		\item Esattamente $k$ componenti connesse del grafo sono alberi
		\item Ogni componente connessa del grafo ha almeno $h$ vertici
	\end{itemize}

	\subsection*{Spiegazione}
	Per creare questo algoritmo occorre modificare DFS:
	\begin{itemize}
		\item Per capire quanti alberi ci sono, inizializzo un boolean TREE a True. In visit controllo gli archi all'indietro e metto TREE = False se ne trovo. Al ritorno in DFS, se TREE è True incremento un contatore che alla fine di DFS controllerò che equivalga a k
		\item Per capire il numero di Vertici in una CC, in VISIT incremento un contatore ricorsivamente ogni volta che incontro un nodo white. Una volta tornato in DFS controllo che la CC abbia almeno $h$ vertici.
	\end{itemize}

	\subsection*{Pseudocodice}
	\begin{lstlisting}[mathescape=true]
    DFS-CONDITIONS(G,h,k)
        for ogni $u \in V$
            col[u] = WHITE
            $\pi$[u] = NIL
        tree = True     #variabile globale
        n_trees = 0
        for ogni $u \in V$
            if col[u] == White
                n_vertici = DFS-VISIT-CONDITIONS(u)
                if n_vertici < h
                    RETURN False
                if tree == True
                    n_trees = n_trees + 1
                else
                    tree = true
        if n_trees == k
            RETURN True
        else
            RETURN False
\end{lstlisting}

	\begin{lstlisting}[mathescape=true]
    DFS-VISIT-CONDITIONS(u)
        col[u] = Gray
        n_vertici = 0
        for ogni $w \in$ Adj[u]\$\pi$[u]
            if col[w]==White
                $\pi$[w] = u
                n_vertici = n_vertici + DFS-VISIT-CONDITIONS(w)
            else if col[w] == Gray and tree = True
                tree = False
        col[u] = Black
        return n_vertici + 1
\end{lstlisting}

	\section{Esercizio k grafi completi e h vertici}
	Dati due interi h,k>0 e un grafo non orientato  in cui ad ogni vertice è associato un simbolo (\$ e *)
	stabilisci se: ogni CC del grafo ha almeno h vertici a cui è associato il simbolo \$
	e ci sono al più k componenti connesse del grafo che prese singolarmente sono grafi completi

	\subsection*{spiegazione}
	\begin{itemize}
		\item h vertici per cc..., ogni volta che trovo un vertice white aumento un counter se è associato al dollaro, e alla fine controllo se è > h
		\item k cc sono.... un grafo è completo se ci sono $n_{vert} \cdot (n_{vert} -1)/2$ archi. per contare gli archi si incrementa un counter ogni volta che si trova un vertice nella lista di adiacenza.
	\end{itemize}

	\subsection*{Pseudocodice}
	\begin{lstlisting}[mathescape=true]
DFS_CUSTOM(G,h,k)
    for ogni $u \in V$
        col[u] = WHITE
        $\pi$[u] = NIL
    n_completi = 0
    n_archi = 0
    for ogni $u \in V$
        if col[u] == WHITE
            n_dollari = DFS_VISIT_CUSTOM(u)
            if n_dollari < h
                RETURN False
            if n_archi = n_vertici $\cdot$ (n_vertici - 1)/2
                n_completi = n_completi + 1
            n_archi = 0
    if n_completi > k
        RETURN False
    RETURN True
\end{lstlisting}

	\begin{lstlisting}[mathescape=true]
DFS_VISIT_CUSTOM(u)
    col[u] = GRAY
    if f(u) == "dollar"
        n_dollar = 1
    else
        n_dollar = 0
    for ogni $w \in Adj[u]\backslash\pi[u]$
        n_archi = n_archi + 1
        if col[w] == WHITE
            $\pi$[w] = u
            n_dollar = n_dollar + DFS_VISIT_CUSTOM(w)
    RETURN n_dollar
\end{lstlisting}

	\section{Esercizio conta CC di un grafo}
	Scrivere un algoritmo che determina il numero di componenti connesse di un grafo G =
	(V, E) non orientato.

	\subsection*{Spiegazione}
	Ogni volta che DFS invoca DFS-VISIT significa che ha trovato una componente connessa, quindi basta mettere un contatore che incrementa ogni volta che si chiama DFS-VISIT da DFS
	\subsection*{Pseudocodice}
	\begin{lstlisting}[mathescape=true]
    DFS_COUNT_CC(G)
        for ogni $u \in V$
            col[u] = WHITE
        count = 0
        for ogni $u \in V$
            if col[u] == WHITE
                count = count + 1
                DFS_VISIT(u)
        RETURN count
\end{lstlisting}

	\section{Esercizio Controlla se G è Aciclico}
	Modificare l’algoritmo DFS di visita di un grafo orientato G in maniera tale che stabilisca
	se G è acicilico, ossia se non contiene cicli.
	\subsection*{Spiegazione}
	Un grafo è aciclico se non contiene nessun arco all'indietro (btw se un grafo non orientato è aciclico allora è un albero).
	\\Quindi bisogna semplicemente iniziallizzare un Boolean "acyclic" a TRUE e farlo diventare FALSE qual'ora si incontrasse un arco all'indietro

	\subsection*{Pseudocodice}
	\begin{lstlisting}[mathescape=true]
DFS-ACYCLIC(G)
    for ogni $u \in V$
        col[u] = WHITE
        $\pi$[u] = NIL
    time = 0
    acyclic = true
    for ogni $u \in V$
        if col[u] == WHITE
            DFS-VISIT-ACYCLIC(u)
    return acyclic    
\end{lstlisting}

	\begin{lstlisting}[mathescape=true]
DFS-VISIT-ACYCLIC(u)
    col[u] = GRAY
    time++
    d[u] = time
    for ogni $w \in$ Adj[u]
        if color[w] == WHITE
            $\pi$[w] = u
            DFS-VISIT-ACYCLIC(w)
        else if col[w] == GRAY and acyclic == true
            acyclic = FALSE
    col[u] = black
    time ++
    f[u] = time
\end{lstlisting}

	\subsection*{In caso di grafo NON ORIENTATO}
	Se il grafo non è orientato, l'algorimto è lo stesso ma nel controllo degli adiacenti di u in visit bisogna togliere il padre di u

\chapter{Esami}
\section{12 Settembre 2016}
\subsection{Esercizio 1}
\paragraph*{Testo}Sia $A$ l'insieme dei numeri interi escluso 0.
\\Dato un grafo non orientato $(V,E,f)$ in cui ad ogni vertice è associato un numero intero diverso da zero
(mediante la funzione $f: V\to A)$, mediante la tecnica della programmazione dinamica, si vuole stabilire, per ogni coppia di vertici $(i,j)$,
se esiste un cammino da $i$ a $j$ avente vertici che danno luogo ad una alternanza del segno dei numeri ad essi associati.
RISPONDERE PER PUNTI alle seguenti richieste
\begin{enumerate}
	\item Esplicitare e definire le variabili che servono per risolvere il problema
	\item Scrivere l'equazione di ricorrenza per il CASO BASE, giustificando perchè è fatta in quel modo
	\item Scrivere la/le equazione/i di ricorrenza per il PASSO RICORSIVO, giiustificando perchè è/sono fatte in quel modo
	\item scrivere qual'è la soluzione del problema, espressa rispetto alle variabili introdotte.
\end{enumerate}

\paragraph*{1:} 
Introduco la funzione $s: A\to \{+,-\}$.
\subparagraph*{Sottoproblema $k$-esimo}
Dato un grafo $(V,E,f)$ e $k\in \{0,...,n\}, \forall(i,j) \in V\times V$ si vuole stabilire se esiste un cammino $p$
da $i$ a $j$ avente vertici intermedi appartenenti a $\{1,...,k\}$ e in cui non ci siano due vertici consecutivi a cui è associato un numero con lo stesso segno.
\\Ad ogni sottoproblema di dimensione $k$ è associata una variabile:  
\subparagraph*{Variabile}
Sia $k\in\{0,...,n\}$, $\forall (i,j) \in V\times V$, introduciamo la variabile $d^{(k)}_{(i,j)}$ così definita:
\begin{itemize}
	\item TRUE, se esiste un cammino $p$ da $i$ a $j$ avente vertici intermedi appartenenti a $\{\,...,k\}$ e in cui non ci siano due vertici consecutivi a cui è associato un numero con lo stesso segno.
	\item FALSE, altrimenti
\end{itemize}
Pertanto al sottoproblema $k$-esimo è associata la macrovariabile $D^{(k)}$ il cui generico elemento è $d^{(k)}_{(i,j)}$.
\paragraph*{2:} CASO BASE $k=0$.
\\Si consideri la generica coppia di vertici $(i,j)$.
Nel problema si vuole stabilire se esiste un cammino $p$ da $i$ a $j$ avente vertici intermedi appartenenti a $\{1,...,k\}$ e in cui non ci siano due vertici consecutivi a cui è associato lo stesso segno.
Se $k$ è pari a 0, allora non esistono vertici intermedi.
Per cui sono possibili due situazioni:
\begin{itemize}
	\item Può esistere al massimo un arco che collega $i$ e $j$ (se essi sono due vertici distinti), In tal caso la variabile vale TRUE sse $s(f(i))\neq s(f(j))$.
	\item Se non esiste alcun arco tra $i$ e $j$ e sono nel caso degenere per cui $i=j$, allora la variabile vale TRUE.
\end{itemize}
In tutti gli altri casi la variabile vale false.
$$d^{(0)}_{(i,j)}= \begin{cases}
	TRUE & \text{se } i\neq j \wedge (i,j)\in E \wedge s(f(i)) \neq s(f(j)) \vee i=j \\
	FALSE & \text{Altrimenti}
\end{cases}
$$
\paragraph*{3} PASSO RICORSIVO $k\geq 0$
Si consideri la generica coppia $(i,j)$ e sia $k\in\{1,...,n\}$.
\\Si possono presentare due diverse situazioni:
\begin{itemize}
	\item $k\notin p$: Se $k$ non è un vertice intermedio di $p$ (tra $i$ e $j$), allora tutti i vertici intermedi di p appartengono all'insieme $\{1,...,k-1\}$.
	Esiste un cammino $p$ da $i$ a $j$ avente vertici intermedi appartenenti a $\{1,...,k\}$ e in cui non si siano due vertici consecutivi a cui è associato un numero con lo stesso segno se esiste
	un cammino $p$ da $i$ a $j$ avente vertici intermedi appartenenti a $\{1,...,k-1\}$ con le medesime condizioni
	$$\forall(i,j)\in V\times V, d^{(k)}_{(i,j)} = d^{(k-1)}_{(i,j)} \text{ sse } k\notin p$$
	Per semplicità chiamo questo caso $C_1$
	\item$k\in p$: se $k$ è un vertice intermedio di $p$ (tra $i$ e $j$), suddivido $p$ in due sottocammini $p_1$ da $i$ a $k$ e $p_2$ da $k$ a $j$,
	entrambi aventi vertici intermedi appartenenti all'insime $\{1,...,k-1\}$.
	Per la proprietà della sottostruttura ottima si avrà:
	$$\forall(i,j)\in V\times V, d^{(k)}_{(i,j)} = d^{(k-1)}_{(i,k)} \wedge d^{(k-1)}_{(k,j)} \text{ sse } k\in p$$
	Per semplicità chiamo questo caso $C_2$
\end{itemize}
Poichè non posso sapere a priori se $k$ sia o meno vertice intermedio di $p$, avrò il caso passo:
$$\forall(i,j)\in V\times V, d^{(k)}_{(i,j)} = C_1 \vee C_2$$
\paragraph*{4}Soluzione:
La soluzione del problema PB è costituita da tutti i valori contenuti in $D^{(n)}$.



\chapter{Domande di Teoria}

	\section{Domande date da Dennunzio}
	\paragraph*{}Queste domande vengono da un file che ha distribuito il Professor Dennunzio.

	\domanda{1}{
		Siano $X=<x_1,...,x_m>$ e $Y=< y_1,...,y_n>$ due sequenze e sia $Z=<z_1,...,z_k>$
		una LCS di X e Y. Scrivere la proprieta’ di sottostruttura ottima di Z
	}
	\risposta{
		Siano $X=\{x_1,x_2,...,x_m\}$ e $Y=\{y_1,y_2,...,y_n\}$ le sequenze; sia $Z=\{z_1,z_2,...,z_m\}$ una qualsiasi LCS di X e Y.
		\begin{enumerate}
			\item Se $x_m = y_n$, allora $z_k = x_m =y_n$ e $Z_{k-1}$ è  una LCS di $X_{m-1}$ e $Y_{n-1}$
			\item Se $x_m \neq y_n$, allora $z_k \neq x_m$ implica che Z è una LCS di $X_{m-1}$ e $Y$
			\item Se $x_m \neq y_n$, allora $z_k \neq y_n$ implica che Z è una LCS di $X$ e $Y_{n-1}$
		\end{enumerate}
	}
	\reflibro{Teorema 15.1 pag 325}
	\domanda{2}{
		Scrivere le equazioni di ricorrenza per risolvere il problema della LCS di due
		sequenze, specificando bene il significato delle variabili coinvolte
	}
	\risposta{
		\begin{equation*}
			c[i,j] = \begin{cases}
				0                       & \text{se $i = 0$ or $j = 0$}           \\
				c[i-1,j-1] + 1          & \text{se $i,j > 0$ and $x_i = y_j$}    \\
				max(c[i,j-1], c[i-1,j]) & \text{se $i,j > 0$ and $x_i \neq y_j$} \\
			\end{cases}
		\end{equation*}
		$c[i,j]$ è una matrice contenente la lunghezza di una qualsiasi LCS delle sottosequenze di lunghezza rispettivamente $i$ e $j$ di $X$ e $Y$
	}
	\reflibro{“Fase 2: una soluzione ricorsiva” pag. 325}
	\domanda{3}{
		Scrivere l’algoritmo che determina la lunghezza della LCS di due sequenze
		specificando il suo tempo di calcolo\\
	}
	\risposta{
		Tempo di esecuzione di LCS-LENGHT: $\theta(mn)$ perchè il calcolo di ogni posizione della tabella richiede 1.
	}
	%lstlisting non va dentro \risposta per cose di variabili e boh
	\begin{lstlisting}[mathescape=true] 
LCS-LENGHT(X,Y)
m = X.lenght
n = Y.lenght
Siano b[1..m,1..n] e c[0..m,0..m] due nuove tabelle
for i = 1 to m
    c[i,0] = 0
for j= 0 to n
    c[0,j] = 0
for i = 1 to m
    for j = 1 to n
        if $x_i$ == $y_i$
            c[i,j] = c[i-1,j-1] + 1  
            b[i,j] = $\nwarrow $
        elseif c[i - 1,j] $\geq$ c[i,j-1]
            c[i,j] = c[i-1,j]  
            b[i,j] = $\uparrow $
        else
            c[i,j] = c[i,j-1]  
            b[i,j] = $\leftarrow $
return c e b
\end{lstlisting}
	\reflibro{"Fase 3: Calcolare la lunghezza di una LCS" pag.326}

	\domanda{4}{
		Definire qual è il sottografo dei predecessori (o albero BFS) prodotto dalla
		visita BFS di un grafo $G=<V,E>$, specificando bene da quali vertici e quali
		archi e’ composto.
	}
	\risposta{
		Il sottografo dei predecessori $G_\pi <V_\pi, E_\pi>$ è un albero BF (o albero di visita in ampiezza) se:
		$V_\pi$ è formato da vertici raggiungibili da $s$ e, per ogni $v \in V_\pi$, c'è un solo cammino semplice da $s$ a $v$ in $G_\pi$ che è anche un cammino minimo da $s$ a $v$ in $G$.
		GLi archi in $E_\pi$ sono detti \emph{archi dell'albero}.
	}
	\reflibro{“Alberi di visita in ampiezza”  pag. 502}
	\domanda{5}{
		Scrivere qual e’ il tempo di calcolo dell’algoritmo BFS motivando BENE la
		risposta (fare riferimento allo pseudocodice).
	}
	\risposta{
		Il tempo totale di esecuzione di BFS è $O(V + E)$.\\
		Di cui $O(V)$ è il tempo delle operazioni con la coda, e $O(E)$ è il tempo per l'ispezione di ADJ.
	}
	\reflibro{"Analisi" pag 499}
	\domanda{6}{
		Spiegare il significato dei colori assegnati ai vertici dall’algoritmo BFS.
		Alla fine dell’esecuzione dell’algoritmo BFS su un grafo $G=<V,E>$, quali colori assumono i vertici?
	}
	\risposta{
		BFS assegna ad ogni vertice del grafo un colore:
		\\\emph{Bianco} per i vertici non ancora scoperti, \emph{Grigio} per i vertici scoperti ma di cui ancora non è stata scandita del tutto la lista di adiacenza
		e \emph{Nero} ad ogni vertice scoperto di cui è stata scandita l'intera lista di adiacenza.
		\\Alla fine dell'esecuzione di BFS, ogni nodo appartenente alla componente connessa del nodo sorgente assumera il colore \emph{nero}
	}
	\domanda{7}{
		Definire qual e’ il sottografo dei predecessori (o foresta DF) prodotto dalla visita DFS di un grafo $G=<V,E>$,
		specificando bene da quali vertici e quali archi e’ composto.
	}
	\risposta{
	Il sottografo dei predecessori o foresta DF è così definita:
$G\pi = (V, E\pi )$ , dove:
$E\pi = {(\pi[v], v) : v \in V \land \pi[v] \neq NIL}$
	\\In pratica, $G_\pi$ è formato da tutti i vertici di $G$ e tutti gli archi che vanno dal "padre" di un nodo $v$ a $v$.
	}

	\domanda{8}{
		Descrivere la classificazione degli archi che la visita in profondità produce a partire da un grafo $G=<V,E>$.
		Come si classifica un generico arco $(u,v)$ del grafo?
	}
	\risposta{
		DFS classifica gli alberi in questo modo:
		Arco dell'albero: ogni arco che va a scoprire un nuovo vertice,
		Arco all'indietro: se va in un nodo grigio,
		Arco in avanti: se va in un nodo nero scoperto dopo u,
		Arco di attraversamento: se va in un nodo nero scoperto prima di u.
	}
	\domanda{9}{
		Scrivere qual e’ il tempo di calcolo dell’algoritmo DFS motivando bene la
		risposta (fare riferimento allo pseudocodice)}
	\risposta{
		DFS ha un tempo di esecuzione di $\theta(V+E)$.
		DFS-VISIT è chiamata una volta per ogni vertice (quando è bianco, quindi $\theta(V)$)
		e il ciclo in DFS-VISIT è chiamato una volta per ogni arco (ogni volta che c'è una adiacenza, quindi $\theta(E)$)
	}
	\domanda{11}{
		Dare la definizione di ordinamento topologico, specificando bene a che tipo di
		grafo si applica. Descrivere come si ottiene l’ordinamento topologico
		sfruttando l’algoritmo DFS
	}
	\risposta{
		Un ordinamento topologico di un DAG G è un ordinamento lineare di tutti i suoi vertici tale che, se G contiene un arco (u,v), allora u appare prima di v nell'ordinamento.
		l'algoritmo TOPOLOGICAL-SORT(G) per ottenere un ordinamento topologico chiama DFS per calcolare i tempi di completamento $v.f$ e poi completata l'ispezione inserisce il vertice in una lista concatenata che poi ritorna.
	}

	\domanda{12}{
		Descrivere la caratterizzazione della struttura di un cammino minimo $p=< v1, …, vl>$ utilizzata dall’algoritmo di Floyd-Warshall.
	}
	\risposta{
	L'algoritmo considera i vertici "intermedi" di un cammino minimo, dove un vertice intermedio di un cammino semplice $p=<v_1,..,v_l>$
	è un vertice qualsiasi di $p$ diverso da $v_1$ e $v_l$ ovvero un vertice qualsiasi dell'insieme $\{v_2,...,v_{l-1}\}$.
%non l'ho capita bene    
}
\domanda{13}{
	Illustrare e motivare le equazioni di ricorrenza su cui si basa l’algoritmo di
	Floyd-Warshall, specificando bene il significato delle variabili coinvolte.}
\risposta{
	Equazione di ricorrenza:
	\begin{equation*}
		d_{ij}^k = \begin{cases}
			w_{ij}                                          & k=0 \\
			min\{d_{ij}^{k-1},d_{ik}^{k-1} + d_{kj}^{k-1}\} & k>0
		\end{cases}
	\end{equation*}
	in cui: $w_ij$ è il peso dell'arco da $i$ a $j$, $d_{ij}^k$ è il peso del cammino minimo da $i$ a $j$ usando al più i vertici di indice $k$.
	$d_{ij}^k$ assume il valore del peso dell'arco diretto tra $i$ e $j$ se non ci sono archi intermedi, altrimenti il minore tra il cammino minimo usando un vertice intermedio in meno e la somma di due cammini minimi usando un vertice intermedio in meno.
}

\domanda{14}{
	illustrare un metodo per costruire i cammini minimi nell’algoritmo di Floyd-Warshall.
}
\risposta{
	Per costruire i cammini minimi in FW calcolo la matrice D dei pesi dei cammini minimi e poi costruisco la matrice dei predecessori della matrice D.
}
\domanda{15}{
	Che cos'è la \textbf{chiusura transitiva} di un grafo orientato?
	Descrivere un modo per calcolarla.
}
\risposta{
	La \emph{chiusura transitiva} di un grafo orientato è un grafo che ha un arco da un nodo $i$ a $j$ se nel grafo originale esiste un cammino tra i due.
	\\Più formalmente: dato un grafo orientato si vuole determinare se per ciascuna coppia di vertici $i,j$ esiste un cammino da i a j.
	La chiusura transitiva è definita come il grafo $G* = (V,E*)$ dove $E* = \{(i,j)$: esiste un cammino dal vertice $i$ al vertice $j$ in $G\}$\\
	\\Un modo per calcolare la CT di un grafo consiste nell'assegnare un peso 1 a ogni arco di $E$ e nell'eseguire FW.
	se esiste un cammino da $i$ a $j$ si ha $d_{ij}$ < n, altrimenti infinito.
}
\domanda{16}{
	Descrivere come modificare le equazioni di ricorrenza dell’algoritmo di Floyd-Warshall per calcolare la chiusura transitiva di un grafo orientato.
}
\risposta{
	La variabile $t_{ij}^k$ assume valore $1$ se esiste un cammino da $i$ a $j$ utilizzando al più vertici intermedi di indice $k$, 0 altrimenti (equivalgono a \emph{True} e \emph{False})
	\\Per $k=0$
	\begin{equation*}
		t_{ij}^0 = \begin{cases}
			0 & i \neq j \land (i,j) \notin E \\
			1 & i = j \lor (i,j) \in E        \\
		\end{cases}
	\end{equation*}
	$k>0$
	\begin{equation*}
		t_{ij}^k = t_{ij}^{k-1} \lor (t_{ik}^{k-1} \land t_{kj}^{k-1})
	\end{equation*}
}

\domanda{17}{
	Dare la definizione di:
	\begin{enumerate}
		\item Sistema di Indipendenza.
		\item Problema associato ad
		      un coppia costituita da un sistema di indipendenza e da funzione peso definita
		      sul sistema di indipendenza.
	\end{enumerate}
	Scrivere inoltre qual è l’algoritmo Greedy associato a tale coppia.
}
\risposta{
	\begin{enumerate}
		\item Sistema di indipendenza: Data la coppia $<E,F>$ dove $E$ è un insieme finito e $F$ è una famiglia di sottoinsiemi di $E$, definiamo tale coppia sistema di indipendenza se vale la seguente proprietà:
		      \begin{equation*}
			      \forall A \in F se B \subseteq A \implies B \in F
		      \end{equation*}
	\end{enumerate}

}
\domanda{18}{
	Definire cos’è un matroide, enunciare il Teorema di Rado.}
\risposta{
	Un \emph{Matroide} è un sistema di independenza che rispetta la seguente proprietà:
	$$
		\forall A, B \in F \text{ e } |A| = |B| + 1 \implies \exists a \in A\backslash B \text{ tale che } B \cup \{a\} \in F
	$$
	il Teorema di Rado dice: Dato un sitema di indipendenza $<E,F>$ le seguenti proposizioni sono equivalenti:
	\begin{itemize}
		\item Per ogni funzione peso $w : E \to R+$, l'algoritmo greedy associato fornisce una soluzione ottima
		\item $<E,F>$ è un matroide
	\end{itemize}
}
\domanda{19}{
	Cos’è una struttura dati per insiemi disgiunti? Definire formalmente quali
	sono le operazioni principali su una struttura dati per insiemi disgiunti.
}
\risposta{
    Una struttura dati per insiemi disgiunti è un tipo di struttura dati che serve a mantenere una collezione di insiemi disgiunti
	in cui ogni insieme è identificato da un \emph{rappresentante} (che è un elemento dell'insieme)
	e ogni elemento di un insieme è rappresentato da un oggetto $x$.
    \\Le operazioni principali sono:
	\begin{itemize}
		\item \emph{Make-set(x)}: Crea un nuovo insieme con $x$ come unico elemento.
		\item \emph{Find-set(x)}: Restituisce un puntatore al rappresentante del set in cui è contenuto $x$.
		\item \emph{Union(x,y)}: Unisce gli insiemi di cui $x$ e $y$ fanno parte.
	\end{itemize}
}

\domanda{20}{
	Illustrare i possibili modi con cui è possibile rappresentare una struttura dati per insiemi disgiunti e complessità relative
}
\risposta{
	Una semplice rappresentazione di questi insiemi è data dalle \emph{liste concatenate}.
	Il primo oggetto di ogni lista viene utilizzato come rappresentante.
	Ogni oggetto nella lista ha i seguenti campi:
	\begin{itemize}
		\item info: l'informazione contenuta nel nodo
		\item rappr: il puntatore al rappresentante
		\item succ: il puntatore al nodo successivo
	\end{itemize} 
}

\domanda{21a}{Definire formalmente cos'è un albero di compertura minimo(MST).}
\risposta{
	Sia $G(V,E)$ un grafo \emph{Pesato} tramite la funzione $w:E\to \mathbb{R}$, \emph{Connesso} e \emph{non orientato}.
	\\Se $G_{c}(V,T)$ è un albero con $T\subseteq E$ ed è aciclico, allora $G_c$ è un albero di copertura di $G$.
	\\Un albero di copertura minimo (MST) di $G$ è un Albero Aciclico $G_{MST}(V,T)$ con $T\subseteq E$ tale che:
	$$w(T) = \text{min}\{w(A) | A \subseteq E \wedge (V,A) \text{ albero di copertura di }G\}$$ 

}
\domanda{21b}{
	Illustrare l'approccio greedy generico, fornendo la procedura GENERIC-MST,
	per determinare un MST illustrando il principio di funzionamento (cosa fa la proceduara ad ogni iterazione,
	proprietà invariante di ciclo, nozione di arco sicuro, ecc).
}
\domanda{21c}{Come si trova un'arco sicuro?}
\domanda{21d}{Dare le definizioni di: taglio, arco che attraversa un taglio, taglio che rispetta un sottoinsieme di archi, arco leggero.}
\risposta{
Sia $G(V,E)$ un grafo non orientato e connesso, valgono le seguenti definizioni:	
\\\emph{Taglio}:Si definisce \emph{Taglio del Grafo} $G$ una partizione $(S,V-S)$, dell'insieme dei vertici del grafo $V$.
\\\emph{Arco che attraversa un Taglio}: Sia $(S,V-S)$ un taglio di $G$. Si dice che un arco $(u,v)\in E$ attrversa il taglio se: $u\in S \wedge v\in V-S \vee u\in V-S \wedge v\in S$ }
\\\emph{Taglio che rispetta un insieme di archi}: Si dice che il taglio $(S,V-S)$ rispetta l'insieme A se nessun arco di A attraversa il taglio.


\domanda{21e}{Enunciare il Teorema che da una condizione sufficiente affinchè un arco sia sicuro.}
\risposta{Sia $G(V,E)$ un grafo connesso, non orientato e pesato. Siano inolre:
\begin{enumerate}
	\item $A\subseteq E$ un sottoinsieme di archi di un MST, che indichiamo con T, di G.
	\item (S,V-S) un taglio definito su G che rispetta A;
	\item $(u,v)\in E$ un arco del grafo di peso minimo che attraversa il taglio definito su $G$.
\end{enumerate}
Allora $(u,v)$ è un arco sicuro per A, cioè se ad A aggiungiamo anche l'arco (u,v) allora A continua a rappresentare un sottoinsieme di archi di un MST.

}

\domanda{22}{
	Illustrare gli algoritmi di Kruskal e Prim facendo riferimento alla procedura GENERICS-MST.
	Che differenze tra i due rispetto all'insieme A e a cosa è un arco sicuro.
	Complessità computazionale dei due algoritmi.
}
\domanda{23}{Complessità computazionale dell'algoritmo di Floyd-Warshall (giustificare)}
\risposta{L'algoritmo di Floyd-Warshall ha una complessità di $O(|V|^3)$.
Questo algoritmo contiene tre cicli \emph{for} di dimensione $|V|$,
in cui confronta il cammino di ogni nodo con ogni altro nodo usando al più ogni "livello" di nodi intermedi.

}

\section{Domande dagli Esami}
\domanda{}{Descrivere come usare la DFS per calcolare le componenti connesse di un grafo non orientato.}
\risposta{
Per il funzionamento dell'algoritmo, ogni volta che \emph{DFS} chiama \emph{DFS-VISIT} su un nodo bianco, significa che ha trovato una nuova componente connessa.
Se si volesse trovare il numero di CC di un grafo, basta mettere un contatore che viene incrementato ogni volta che \emph{DFS} chiama \emph{DFS-VISIT}}

\domanda{Descrivere come la visita BFS produce un'albero BFS dando descrizione dell'algoritmo e delle variabili che utilizza}

\end{document}