\chapter{Strato di trasporto}
\section{Servizi e protocolli di trasporto}
Forniscono una comunicazione logica tra \textbf{processi applicativi} che risiedono su host diversi.
\begin{description}
    \item[Cos'√® una comunicazione logica?] Fa s√¨ che i processi che stanno comunicando lo facciano, si scambino cio√® dati, come se fossero sullo stesso host (ovviamente non lo sono). Di fatto trasparente al livello superiore. Come il livello applicativo, si comporta come se senti registrazione.
    \item[Come si comporta:] spezzetta l'informazione in segmenti che trasporta poi a livello di rete.
    \item[Due tipi che vedremo:] two major transport protocols available to Internet applications: 
    \begin{description}
        \item[TCP:] Transmission Control Protocol
        \item[UDP:] User Datagram Protocol\\
        Best-effort: I messaggi vengono inviati, se arrivano bene, se non arrivano va bene lo stesso.
    \end{description}
\end{description}

\subsection{Differenze livello di trasporto e livello di rete}
\begin{description}
    \item[l. di rete:] comunicazione logica fra host
    \item[l. di trasporto:] comunicazione logica fra processi
\end{description}

\subsection{Socket}
Quando si parla di protocolli a livello di trasporto si deve introdurre il concetto di \textbf{\textit{socket}}. Quando un processo deve comunicare con un altro processo, deve avere un'interfaccia di comunicazione. Questa interfaccia √® il socket.
\definizione{Una socket √® un'interfaccia verso cui vengono spinti e ricevuti i messaggi che devono essere ricevuti da/inviati a un processo.}
Permette di mettere in comunicazione i processi eseguiti a livello applicativo e il livello di trasporto.\\
N.B.: un processo pu√≤ gestire pi√π di una socket contemporaneamente.\\
Avremo bisogno di
\begin{itemize}
    \item 1 socket per \textbf{sender}
    \item 1 socket per \textbf{receiver}
\end{itemize}
La pila protocollare da livello fisico a livello di trasporto √® gestita dal \textit{sistema operativo}. Lo sviluppatore pu√≤ programmare quella parte di socket esposta verso il processo applicativo.\\
Per ricapitolare, il messaggio far√†: \texttt{livello applicativo $\rightarrow$ socket $\rightarrow$ livello di trasporto $\rightarrow$ livello di rete $\rightarrow$ livello fisico $\rightarrow$ livello fisico $\rightarrow$ livello di rete $\rightarrow$ livello di trasporto $\rightarrow$ socket $\rightarrow$ livello applicativo}.

\section{TCP e UDP}
\subsection{TCP, Transmission Control Protocol}
Si assicura che tutti i segmenti di informazione vengano consegnati \textit{correttamente} e \textit{in ordine}. Garantisce la consegna affidabile e la connessione affidabile fra mittente e destinatario.\\
Offre altri servizi: 
\begin{description}
    \item[controllo della congestione:] per evitare di contribuire alla congestione della rete fa capire al mittente di diminuire il numero di segmenti inviati.
    \item[controllo di flusso:] non riguarda la rete ma il destinatario. Se il destinatario non √® in grado di ricevere i segmenti, il mittente non li invia.
    \item[√® connection-oriented:] chiede che vengano istituite connessioni fra le parti prima di poter inviare i dati.
\end{description}
\`E molto importante per le \textit{applicazioni elastiche}, che non sono in alcun modo tolleranti per quanto riguarda la perdita di dati ma molto pi√π tolleranti per quanto riguarda i ritardi. TCP √® perfetta.\\
Nessuno di questi due protocolli garantisce:
\begin{itemize}
    \item un limite sui ritardi
    \item garanzie sulla banda (es. non posso dire "ho almeno 10 Mbit di banda per questa connessione").
\end{itemize}

\subsubsection{TCP, principi della trasmissione affidabile dei dati}
Cosa ci serve? Un canale di comunicazione affidabile. Ma nella realt√† affidabile non lo √® mai. A livello di trasporto bisogna implementare una tecnologia per rendere affidabile la comunicazione.\\
Servono servizi di feedback, il destinatario deve dirmi se gli sono arrivati i dati. Ho perso cose.

\subsection{Reliable data transfer}
Raffigurato c'√® un diagramma da spiegare (inserisci qua screen).
A sinistra ho l'asse dei tempi, a sinistra avr√≤ \texttt{A} e a destra \texttt{B} e \texttt{A} comunica con \texttt{B}. Da \texttt{A} a \texttt{B} ho frecce che vanno in diagonale perch√©? Senti.
\\
Consideriamo un modello di rete ideale, ovvero:
\begin{itemize}
    \item non ci sono errori di bit
    \item perdite di segmenti/pacchetti
    \item ritardi di trasmissione dei segmenti/pacchetti
\end{itemize}
Cos√¨ diventa superfluo il modello di reliable data transfer perch√© la rete √® gi√† ottimale e affidabile, nessun bisogno di meccanismi di feedback etc.\\
Non √® cos√¨ ovviamente in verit√†, quindi bisogna implementare un reliable data transfer.\\
Avendo errori, una cosa che posso fare √® introdurre \textit{due messaggi}:
\begin{description}
    \item[positive acknowledgment:] \texttt{ACK} (messaggio di conferma positiva)
    \item[negative acknowledgment] \texttt{NACK} (messaggio di conferma negativa)
\end{description}
\begin{verbatim}
    IF ack,
    THEN M_(i+1)
    ELSE IF nack
        THEN M_i
        ELSE ?
\end{verbatim}
Non funziona, perch√© anche \texttt{ACK} e \texttt{NACK} possono essere soggetti ad errore.\\
Se i miei segmenti \textit{fossero numerati}, riesco a capire se ho perso qualcosa e anche nel caso di duplicati. 
\begin{verbatim}
    IF ack
    THEN M_(i+1)
    ELSE M_i
\end{verbatim}
Se vado a numerare anche gli \textit{acknowledgments}, riesco anche ad evitare l'uso di \texttt{NACK}.\\
Nel momento in cu ricevo un \texttt{$ACK_i$} per il segmento \texttt{M\_i}, so che tutti i segmenti precedenti sono stati ricevuti correttamente. Se ricevo un \texttt{$ACK_i$} per il segmento \texttt{M\_i}, ovvero mando l'\texttt{ack} del segmento precedente, posso capire che il segmento \texttt{M\_i} √® stato perso.
\begin{verbatim}
    IF ack
    THEN M_(i+1)
    ELSE M_i
\end{verbatim}
Le reti per√≤ non introducono solo perdite di segmenti, ma anche ritardi.\\
La perdita pu√≤ capitare al messaggio che sto inviando o all'ack che sto ricevendo. Come gestisco situazioni in cui li perdo entrambi? Devo introdurre un \textit{timer}.\\
Parliamo di protocolli \textbf{\textit{stop-and-wait}}.

Come settiamo questo timer? \`E una cosa complicata ma fondamentale. Se √® troppo alto, se mando un time out spreco un sacco di tempo. Se √® troppo breve, rischio di creare ritrasmissioni inutili, invece di usare il mio canale per comunicare normalmente lo riempio di messaggi inutili. Nelle slide un esempio di ci√≤, timer troppo breve.

\subsubsection{Misurare la performance}
Transmitting a segment at a time and waiting
for its ack before a further transmission (stopand-wait) significantly limits performance
% Example: $ùëÖùëáùëá = 100 ùëöùë†, ùêø = 1 ùëòùëèùë¶ùë°ùëí, ùëÖ = 100 ùëÄùëèùëñùë°/ùë† ‚Üí ùëà = 0,008$.

% 18/10/2023

\subsubsection{Sliding windows protocols}
Sliding window protocols can transit up to $W$
segments while waiting the ack of the first
one
Ci sarebbe da rivedere l'inizio di sta lezione.\\
Qua ho aumentando molto l'efficienza dei protocolli stop-and-wait. Se vado a dimensionare la finestra, posso avere un numero di segmenti che posso inviare prima di ricevere l'ack, quindi molta informazione utile.\\
Perch√© la trasmissione sia continua (ed evitare gli spazi vuoti) il tempo di invio del primo segmento + il tempo di ricezione dell'ack del primo segmento deve essere minore del tempo di trasmissione di $W$ segmenti. Ovvero: $$w\bullet\frac{L}{R} \geq RTT + \frac{L}{R}$$ $$W \geq \frac{RTT \bullet R}{L} + 1$$
\subsubsection{Go-back-N protocol}
Cosa ritrasmetto in caso di errore?
\begin{description}
    \item[Go-back-N:] ritrasmetto tutti i segmenti a partire da quello che ha avuto problemi.\\
    Ma come funziona il Go-back-N?\\
    \begin{description}
        \item[Lato ricevitore:] se ho problemi al segmento 2 (come da immagine), il segmento 3 lo scarto; poi dal segmento 4 mando ack negativi per dire che ho perso qualcosa prima e scarta i segmenti che riceve. Nell'immagine infatti vedo che dopo aver scartato il 5, inizia ad accettare il 2 quando viene ritrasmesso.
        \item[Lato mittente:] quando riceve un ack negativo, ritrasmette tutti i segmenti a partire da quello che ha avuto problemi. Comunque riguarda la registrazione qua.
    \end{description}
    Non c'√® bisogno di implementare un buffering al ricevitore.\\
    Si dice che gli \textit{ack} sono \textit{cumulativi}. Nel momento in cui non ho un segmento mando un ack per l'ultimo segmento ricevuto e uno negativo per tutti i segmenti che non ho ricevuto.\\
    Per come √® fatto il protocollo, ho un solo timer, ogni volta che viene ricevuto correttamente un ack viene resettato e riportato a 0. Questo semplifica di molto l'implementazione.
    \item[Selective repeat:] ritrasmetto solo il segmento che ha avuto problemi.\\
    \includegraphics[width=0.3\textwidth]{./images/aa2324/R_selectiverepeat1.jpg}
    Gli ack \textbf{non} sono cumulativi. Quando scade il timer, ritrasmetto solo il segmento che ha portato al timeout, ovvero alla scadenza di quel timer.
    
\end{description}

\subsection{TCP protocol}
\subsubsection{Overview}
\begin{description}
    \item[point-to-point:] un mittente, un destinatario
    \item[affidabile, byte-stream in ordine:] garantisce che i dati arrivino correttamente e in ordine, non ci sono "message boundaries"
    \item[full duplex data:] flow di dati in entrambe le direzioni nella stessa connessione (MSS: maximum segment size)
    \item[\textit{acks} cumulativi:] 
    \item[pipelining:] TCP congestion and flow control set window size
    \item[connection-oriented:] handshaking (exchange of control messages) initializes sender, receiver state before data exchange
    \item[flow controlled:] sender will not overwhelm receiver     
\end{description}

\subsubsection{TCP, struttura di un segmento}
\includegraphics[0.3\textwidth]{./images/aa2324/R_TCP1.jpg.jpg}
\begin{description}
    \item[source port \#: + dest. port \#:] 16 bit + 16 bit
    \item[sequence number:] 32 bit, numero di sequenza del primo byte di dati nel bytestream
    \item[acknowledgment number:] 32 bit, numero di sequenza del prossimo byte di dati che il mittente si aspetta di ricevere\\
    Sotto, non ho capito il nome, a sinistra del receive window. Noi non la vedremo, pi√π opzioni con lunghezza variabile, dovrebbe contenere l'\textit{header length} di 4 bit, lunghezza dell'header in parole da 32 bit, poi RST, SYN, FIN che si occupando di connection management
    \item[receive window:] flow control, \# bytes che il ricevente √® disposto ad accettare
    \item[checksum:] NOI NON VEDREMO, 16 bit, controllo degli errori
    \item[urgent pointer:] NOI NON VEDREMO, 16 bit, se il flag URG √® impostato, indica il byte successivo al byte urgente
    \item[data:] NOI NON VEDREMO, 0 o pi√π byte di dati
\end{description}

\subsubsection{TCP numeri di sequenza e ACKs}
\begin{description}
    \item[Sequence numbers:] byte stream "number" of first byte in segment's data
    \item[Acknowledgements:] seq \# of next byte expected from other side, cumulative ACK
    \item[Q:] how receiver handles out-oforder segments?
    \item[A:] TCP spec doesn't say, - up to implementor
\end{description}

\subsubsection{TCP, round trip time e timeout}
Q: how to set TCP timeout
value?
‚ñ™ longer than RTT, but RTT varies!
‚ñ™ too short: premature timeout,
unnecessary retransmissions
‚ñ™ too long: slow reaction to
segment loss
Il senso di tutto ci√≤ √® che RTT non √® fisso ma bisogna cercare di settare un timeout sufficiente a permettere al pacchetto di arrivare e al ricevente di rispondere.

Q: how to estimate RTT?
‚ñ™ SampleRTT:measured time
from segment transmission until
ACK receipt
‚Ä¢ ignore retransmissions
‚ñ™ SampleRTT will vary, want
estimated RTT ‚Äúsmoother‚Äù
‚Ä¢ average several recent measurements
(EstimatedRTT),not just current
SampleRTT (quindi una media degli ultimi RTT misurati)

Come lo misuro?
$$EstimatedRTT = (1-\alpha)*EstimatedRTT + \alpha*SampleRTT$$
senti la lezione per capire l'equazione.\\
Per il timeout, aggiungo un margine di sicurezza, tempo aggiuntivo per evitare la situazione in cui metto un timeout troppo breve e ritrasmetto inutilmente. $$TimeoutInterval = EstimatedRTT + 4*DevRTT$$
Dove DevRTT √® il mio margine di sicurezza (perch√© 4* non lo sa nessuno, neanche il prof, credo non lo dicano proprio le specifiche).\\
L'intervallo varia anche in base al valore del RTT stimato.
N.B.: quando apri una connessione e sei appena partito, non hai nessun RTT stimato, quindi di solito si d√† il SampleRTT come valore all'EstimatedRTT.

\subsubsection{TCP Sender (simplified)}
\begin{description}
    \item[data received from application]
    \begin{description}
        \item[create segment with seq #] seq # is byte-stream number of first data byte in segment
        \item[start timer] 
        \begin{itemize}
            \item think of timer as for oldest unACKed segment
            \item expiration interval: TimeoutInterval
        \end{itemize}
    \end{description} 
    \item[timeout] 
        \begin{itemize}
            \item retransmit segment that caused timeout
            \item restart timer
        \end{itemize}
    \item[ACK received:] if ACK acknowledges previously unACKed segments
        \begin{itemize}
            \item update what is known to be ACKed
            \item start timer if there are still unACKed segments
        \end{itemize}
\end{description}

\subsubsection{TCP: retransmission scenarios}
Me lo sono persa

\subsubsection{TCP: fast retransmit}
Me lo sono persa
\definizione{If sender receives 3 additional ACKs for same data ("triple duplicate ACKs"), resend unACKed segment with smallest seq \# (likely that unACKed segment lost, so don't wait for timeout).}
Smallest seq \# perch√© pu√≤ capitare una perdita multipla.\\
importantissimo!!! Unico caso in cui non aspetto il timeout per ritrasmettere.

\subsubsection{TCP controllo di flusso}
Abbiamo detto che avviene nella parte del segmento TCP "receiver window", che si occupa di flow control (\# bytes che il ricevente √® in grado di accettare).
\definizione{Flow control: receiver controls sender, so sender won't overflow receiver's buffer by transmitting too much, too fast.}
\begin{description}
    \item[receive buffer:] fixed amount of buffer space, allocated for a TCP socket
    \item[receiver advertises free buffer space by] including value of RcvWindow in segment
    \item[sender limits unACKed data to] receiver's RcvWindow
    TCP receiver ‚Äúadvertises‚Äù free buffer space in \textbf{rwnd} (receive window) field in TCP header (many operating systems autoadjust RcvBuffer)
    ‚ñ™ sender limits amount of unACKed
    (‚Äúin-flight‚Äù) data to received rwnd
    ‚ñ™ guarantees receive buffer will not
    overflow
\end{description}

\subsubsection{TCP connection management}
before exchanging data, sender/receiver ‚Äúhandshake‚Äù:
‚ñ™ agree to establish connection (each knowing the other willing to establish connection)
‚ñ™ agree on connection parameters (e.g., starting seq #s)
risorse (tipo variabili al centro dell'immagine) da allocare prima dell'handshake.
% immagine

\subsubsection{TCP 3-way handshake, per aprire una connessione}
% immagine
    
\subsubsection{TCP chiudere una connessione}
% immagine
\begin{itemize}
    \item client, server each close their side of connection
        \begin{itemize}
        \item send TCP segment with FINbit = 1 
        \end{itemize}
    \item respond to received FIN with ACK
        \begin{itemize}
        \item on receiving FIN, ACK can be combined with own FIN
        \end{itemize}
\end{itemize}
    
\subsubsection{TCP: controllo congestione}
\definizione{Congestion: informally, "\textit{too many sources sending too much data too fast for network to handle}".}
‚ñ™ manifestations:
‚Ä¢ long delays (queueing in router buffers)
‚Ä¢ packet loss (buffer overflow at routers)
‚ñ™ different from flow control!
NB: controllo di flusso esclusivo del ricevente, controllo di congestione √® un problema di tutti i nodi della rete.
When network gets closer to saturation of available resources, delay and
loss percentage increase
‚ñ™ If the transport layer retransmits messages, the average number of
messages retransmissions increases too
‚ñ™ While throughput (i.e., messages traversing the network) is close to 100\%
of capacity, ‚Äúgoodput‚Äù experienced by the application decreases!
% immagine
Il goodput sono le informazioni che a me effettivamente interessano e droppa cos√¨ nel grafico perch√© gran parte delle informazioni che io ricevo sono ritrasmissioni a me non utili.

\subsubsection{Approaches towards congestion control}
Non andremo a vederla pi√π di tanto e comunque √® vagamente fatto da quale parte del segmento TCP?\\
End-to-end congestion control:
‚ñ™ no explicit feedback from
network
‚ñ™ congestion inferred from
observed loss, delay
Approaches towards congestion control
data data ACKs ACKs
‚ñ™ approach taken by TCP

Network-assisted congestion
control:
‚ñ™ routers provide direct feedback
to sending/receiving hosts with
flows passing through congested
router
‚ñ™ may indicate congestion level or
explicitly set sending rate

Usa un approccio \textit{Additive Increase Multiplicative Decrease}: senders can increase sending rate until packet loss (congestion) occurs, then decrease sending rate on loss event.
\begin{description}
    \item[\underline{A}dditive \underline{I}ncrease]
    \item[\underline{M}ultiplicative \underline{D}ecrease] 
\end{description}
Parliamo di \textit{comportamento a dente di sega} di AIDM, vedi il grafico.
% immagine

TCP sending behavior:
‚ñ™ roughly: send min{cwnd,rwnd}
bytes, wait RTT for ACKS, then send
more bytes
‚ñ™ When cwnd < rwnd, congestion
control is dominant w.r.t. flow
control
% questo sopra affiancato all'immagine dove le lineette verticali sono i bytes.
TCP sender limits transmission: $LastByteSent - LastByteAcked < min{cwnd, rwnd}$
‚ñ™ cwnd is dynamically adjusted in response to observed network
congestion (implementing TCP congestion control)
‚ñ™ rwnd is instead adjusted according to the received value by the receiver
(implementing TCP flow control)
Tre fasi:
\begin{description}
    \item[slow start:] quando inizia la connessione, il rate di invio viene aumentato in maniera esponenziale. Nome un po' infelice (per citare il prof) visto che √® tutto tranne che slow.
    \item[congestion avoindance:] 
        \begin{description}
            \item[Q:] when should the exponential increase switch to linear?
            \item[A:] when cwnd gets to 1/2 of its value before last timeout
            \item[Implementation:]
            \begin{itemize}
                \item variable \textbf{ssthresh}
                \item on loss event, \textbf{ssthresh} is set to 1/2 of the value of \textbf{cwnd} just before loss event
            \end{itemize} 
        \end{description} 
\end{description}
TCP Reno: it adopts the Fast Recovery mechanism after three duplicates acks
\begin{itemize}
    \item set \texttt{cwnd} to \texttt{ssthresh + 3 MSS} (congestion avoidance)
    \item same as TCP Tahoe when timeout is reached
\end{itemize}
% immagine


\subsection{UDP, User Datagram Protocol}
Non offre nessuno dei servizi di TCP. \`E un protocollo \textit{best-effort}.\\
Decisamente meno affidabile di TCP per quanto riguarda perdita di dati e ordine di invio e ricezione.\\
Meglio per le \textit{applicazioni interattive}, che sono tolleranti per quanto riguarda la perdita di dati ma non tolleranti per quanto riguarda i ritardi. UDP √® perfetta.\\
Protocollo tipico: connectionless. Ogni segmento inoltre gestito in modo indipendente dagli altri. Non √® cos√¨ in TCP.\\
Ha dei vantaggi:
\begin{itemize}
    \item non c'√® necessit√† di stabilire una connessione (cosa che introduce ritardi)
    \item √® pi√π semplice (no controllo stato sender/receiver)
    \item header pi√π piccolo
    \item non c'√® controllo di flusso e di congestione
\end{itemize}
Nessuno di questi due protocolli garantisce:
\begin{itemize}
    \item un limite sui ritardi
    \item garanzie sulla banda (es. non posso dire "ho almeno 10 Mbit di banda per questa connessione").
\end{itemize}

\subsubsection{UDP segment header}
Senti lezione per questo pezzetto. E metti screen.
\begin{description}
    \item[source port \#:] 16 bit?
    \item[dest. port \#:] 16 bit?
    \item[length:] in bytes, lunghezza totale del segmento (header + dati).\\
    16 bit?
    \item[checksum:] controllo degli errori, wth is he saying, complemento a 1?!\\
    16 bit?
\end{description}

\subsection{Multiplazione e demultiplazione}
Entrambi i protocolli hanno questi (?) servizi (?):
\begin{description}
    \item[Multiplazione:] l'operazione di multiplexing permette di gestire l'invio di pi√π flussi di dati contemporaneamente verso pi√π socket diverse, andando a inserire valori specifici negli header di trasporto. Operazione fondamentale per la \textit{demultiplazione}.
    \item[Demultiplazione:] comunicazione nella direzione opposta: nello stack protocollare vedo arrivare dati provenienti da processi (veramente socket) differenti. Il receiver ha il compito di andare a vedere (una volta tolti gli header) a quale protocollo mandare i dati.\\
    Usa \textbf{indirizzi IP} (livello di \textit{rete}) e \textbf{numero di porte} (livello di \textit{trasporto}) per indirizzare i dati alle socket corrette.\\
    L'host riceve l'IP da cui arriva il messaggio.
    \begin{description}
        \item[connectionless demultiplexing:] UDP
        \begin{itemize}
            \item Quando creo la socket, devo assegnare un numero di porta \#.
            \item Quando creo il datagram da inviare tramite UDP socket, devo specificare l'intirizzo IP del ricevente e il suo numero di porta \#. Servono entrambe!! Questo perch√©:
            \begin{itemize}
                \item due host diversi possono avere lo stesso numero di porta \#.
                \item un host pu√≤ avere pi√π socket aperte, ognuna con un numero di porta \# diverso.
            \end{itemize}
            \item Quando arriva il datagram, il livello di trasporto estrae l'indirizzo IP e il numero di porta \# (li prende dall'header) e li usa per consegnare il datagram alla socket appropriata.
        \end{itemize} 
        Sulle slide c'√® un esempio molto chiaro: inserisci screen.
        \item[connection-oriented demultiplexing:] TCP\\
        Socket identificata da 4-tuple:
        \begin{itemize}
            \item source IP address.
            \item source port number.
            \item dest IP address.
            \item dest port number.
        \end{itemize} 
        Sulle slide c'√® un esempio molto chiaro: inserisci screen.\\
        Socket strettamente associata alla coppia IP-porta: nell'esempio comunicando da C a B, avr√≤ bisogno di due socket diverse. 
    \end{description}
\end{description}






