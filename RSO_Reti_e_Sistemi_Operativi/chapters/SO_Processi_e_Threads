\chapter{Processi e Threads}
Vedremo sostanzialmente come i s.o. gestiscono \textbf{processi} e \textbf{thread} e cosa si intende con questi due termini.
\section{Argomenti}
\begin{itemize}
    \item Concetto di processo, operazioni e API POSIX
    \item Comunicazione interprocesso e le API POSIX
    \item Multithreading e le API POSIX
\end{itemize}

\section{Concetto di \textit{processo}}
\subsection{Cos'è un processo}
Un s.o. ha come obiettivo il fatto di prendere un sistema di elaborazione e fare in modo che su di esso possano essere eseguiti più programmi in modo concorrente. Il loro numero può essere arbitrariamente elevato, di solito molto maggiore del numero di processori, di CPU del sistema. Il s.o. ci permette però di eseguire il n° di programmi che vogliamo indipendentemente dal n° di CPU che abbiamo. Come?\\
\textit{Il s.o. realizza e mette a disposizione una macchina astratta, un'astrazione detta \textbf{processo}}.\\
\definizione{Un \textbf{processo} è un'entità attiva astratta definita dal sistema operativo allo scopo di eseguire un programma.}
All'interno del s.o. il processo è l'unità esecutiva del programma. Es.: su un pc da 4 CPU, 50 programmi in esecuzione vuole dire 50 processi.\\
Supporremo \textbf{per ora} che l'esecuzione di un processo sia sequenziale e quindi non ci sia concorrenza.

\subsection{Programmi e processi}
Notare la differenza tra \textit{programma} e \textit{processo}!
\begin{itemize}
    \item Un \underline{programma} è un'\underline{entità passiva} (un insieme di istruzioni, tipicamente contenuto in un file sorgente o eseguibile)
    \item Un \underline{processo} è un'\underline{entità attiva} (è un \textit{esecutore di un programma}, o un \textit{programma in esecuzione})
\end{itemize}
Uno stesso programma può dare origine a diversi processi:
\begin{itemize}
    \item \underline{Diversi utenti} eseguono lo \underline{stesso programma}
    \item Uno \underline{stesso programma} viene eseguito \underline{più volte}, anche contemporaneamente, dallo \underline{stesso utente}
\end{itemize}

\subsection{\textit{Multiprogrammazione} e \textit{multitasking}}
Obiettivi del sistema operativo:
\begin{itemize}
    \item Mantenere impegnata la (o le) CPU il maggior tempo possibile nell'esecuzione dei programmi (se ci sono programmi da eseguire)
    \item Dare l'illusione che ogni processo abbia una CPU dedicata
\end{itemize}
Due tecniche adottate nei sistemi operativi sono la \textbf{multiprogrammazione} e il \textbf{multitasking} (o \textbf{time-sharing}, sono sinonimi):
\begin{description}
    \item[Obiettivo della multiprogrammazione:] impedire che un programma che non è in condizione di proseguire l'esecuzione mantenga la CPU
    \item[Obiettivo del multitasking:] far sì che un programma interattivo reagisca agli input utente in un tempo accettabile (è una tecnica \textbf{non} rilevante per i sistemi puramente \textit{batch}, ma lo è principalmente per i programmi interattivi, che continuano a prendere dati dall'utente che li usa)
\end{description}

\subsubsection{Multiprogrammazione: l'implementazione}
Il sistema operativo mantiene in memoria i processi da eseguire.\\
Quando una CPU non è impegnata ad eseguire un processo, il sistema operativo seleziona un processo non in esecuzione e gli assegna la CPU.\\
Quando un processo non può proseguire l'esecuzione (ad es. perché deve attendere il termine dell'input di dati che gli servono per proseguire), la sua CPU viene assegnata ad un altro processo non in esecuzione.\\
Come risultato, se i programmi da eseguire sono più delle CPU, queste saranno impegnate nell'esecuzione di qualche processo per la maggior parte del tempo. Questo risolve il problema dell'efficienza: \textit{non tenere le CPU ferme}.

\subsubsection{Multiprogrammazione: la memoria}
\parbox{0.8\textwidth}{
    La multiprogrammazione richiede che tutte le immagini di tutti i processi siano in memoria perché questi possano essere eseguibili.\\
    Se i processi sono troppi non possono essere contenuti tutti in memoria: la tecnica dello \textbf{swapping} può essere usata per spostare le immagini dentro/fuori dalla memoria. 
    \definizione{\textbf{Swapping} significa che il s.o. può togliere la memoria (anche detta \textit{immagine}) di un processo dalla memoria centrale e caricare l'immagine di un altro processo.}
    La memoria virtuale è un'ulteriore tecnica che permette di eseguire un processo la cui immagine non è completamente in memoria.\\
    Queste tecniche aumentano il numero di processi che possono essere eseguiti in multiprogrammazione, ossia il grado di multiprogrammazione.\\
    Es.: se in un istante sto eseguendo 100 processi, il grado di multiprogrammazione è 100. Se in un altro istante sto eseguendo 50 processi, in quell'istante il grado di multiprogrammazione sarà 50.
}
\hfill
\parbox{0.1\textwidth}{
    \begin{center}
        \includegraphics[width=25mm]{images/aa2324/SO_multiprogrammazione1.jpg}
    \end{center}
}

\subsubsection{Multitasking: l'implementazione}
\`E un'\textit{estensione della multiprogrammazione} per i \underline{sistemi interattivi}.\\
La CPU viene "sottratta" \underline{periodicamente} al programma in esecuzione ed assegnata ad un altro programma. Quindi non più solo quando il programma non è più in grado di proseguire ma anche ogni tot, così tutti i programmi hanno la possibilità di progredire. In questo modo tutti i programmi progrediscono in maniera continuativa nella propria esecuzione, anziché solo nei momenti in cui il programma che detiene la CPU si mette in attesa.\\
Questo permette che i programmi batch, che effettuano poco I/O (e quindi vanno poco in attesa), non monopolizzino la CPU a discapito dei programmi interattivi.

\section{Operazioni sui processi}
I sistemi operativi di solito forniscono delle chiamate di sistema con le quali un processo può creare/terminare/manipolare altri processi.\\
Dal momento che \emph{solo un processo può creare un altro processo}, all'avvio il sistema operativo crea dei processi "primordiali" dai quali tutti i processi utente e di sistema vengono progressivamente creati.\\
Vedremo ora le operazioni fondamentali per:
\begin{itemize}
    \item Creare processi
    \item Terminare processi
\end{itemize}
\section{Creazione di processi}
Chi crea il primo processo? Il s.o., in fase di booth. Il fatto che un processo crei un altro processo dà origine ad una \textbf{gerarchia}. Di solito nei sistemi operativi i processi sono organizzati in maniera gerarchica.\\
Un processo (padre ) può creare altri processi (figli). Questi a loro volta possono essere padri di altri processi figli, creando un albero di processi.\\
Un albero di processi in Linux:
\begin{center}
    \includegraphics[width=40mm]{images/aa2324/SO_operazioniprocessi1.jpg}
\end{center}
La relazione padre/figlio è di norma importante per le politiche di condivisione risorse e di coordinazione tra processi.\\
Possibili politiche di condivisione di risorse:
\begin{itemize}
    \item Padre e figlio condividono tutte le risorse \dots 
    \item \dots o un opportuno sottoinsieme \dots 
    \item \dots o nessuna
\end{itemize}
Possibili politiche di creazione spazio di memoria/indirizzi:
\begin{itemize}
    \item Il figlio è un duplicato del padre (stessa memoria e programma) \dots 
    \item \dots oppure no, e bisogna specificare quale programma deve eseguire il figlio\\
    Questo succede per le API Posix e non per le Win32.
\end{itemize}
Possibili politiche di coordinazione padre/figli:
\begin{itemize}
    \item Il padre è sospeso finché i figli non terminano \dots 
    \item \dots oppure eseguono in maniera concorrente
\end{itemize}

\section{Terminazione di processi}
I processi di regola richiedono esplicitamente la propria terminazione al sistema operativo.\\
Un processo padre può attendere o meno la terminazione di un figlio.\\
Un processo padre può forzare la terminazione di un figlio. \`E sempre brutto terminare forzatamente un processo piuttosto che lasciarlo terminare spontaneamente, ma a volte si rende necessario. Possibili ragioni:
\begin{itemize}
    \item Il figlio sta usando risorse in eccesso (tempo, memoria\dots).
    \item Le funzionalità del figlio non sono più richieste (ma è meglio terminarlo in maniera "ordinata" tramite IPC).
    \item Il padre termina prima che il figlio termini (in alcuni sistemi operativi).
\end{itemize}
Riguardo all'ultimo punto, alcuni sistemi operativi non permettono ai processi figli di esistere dopo la terminazione del padre:
\begin{itemize}
    \item \textbf{Terminazione in cascata:} anche i nipoti, pronipoti\dots\, devono essere terminati (non c'è nelle API Posix).
    \item La terminazione viene iniziata dal sistema operativo.
\end{itemize}
\subsubsection{Es.: API Posix}
\begin{description}
    \item[\texttt{fork()}] crea un nuovo processo figlio; il figlio è un duplicato del padre ed esegue \underline{concorrentemente} ad esso, ritorna al padre un \underline{numero identificatore (PID) del processo figlio} e al figlio il PID 0.
    \item[\texttt{exec()}] sostituisce il programma in esecuzione da un processo con un altro programma, che viene eseguito dall'inizio; viene \underline{tipicamente usata dopo una \texttt{fork()}} dal figlio per iniziare ad eseguire un programma diverso da quello del padre.
    \item[\texttt{wait()}] viene chiamata dal \underline{padre} per attendere la fine dell'esecuzione di un figlio; ritorna:
    \begin{itemize}
        \item Il PID del figlio che è terminato.
        \item Il codice di ritorno del figlio (passato come parametro alla \texttt{exit()}).
    \end{itemize}
    \item[\texttt{exit()}] fa terminare il processo che la invoca:
    \begin{itemize}
        \item Accetta come parametro un codice di ritorno numerico che dice come è andata\\
        (es. tipicamente se il figlio ritorna 0 allora è terminato normalmente, se invece è un numero $\neq 0$ c'è un errore di qualche tipo e il padre deve essere in grado di capire e gestire il codice di errore).
        \item Il sistema operativo elimina il processo e recupera le sue risorse.
        \item Quindi restituisce al processo padre il codice di ritorno (se ha invocato \texttt{wait()}, altrimenti lo memorizza per quando l'invocherà).
        \item Viene implicitamente invocata se il processo esce dalla funzione \texttt{main}.
    \end{itemize}
    \item[\texttt{abort()}] fa terminare forzatamente un processo figlio.
\end{description}
La sequenza \texttt{fork-exec} nelle API POSIX:
\begin{center}
    \includegraphics[width=90mm]{images/aa2324/SO_operazioniprocessi2.jpg}
\end{center}

\subsection{Processi \textit{zombie} e \textit{orfani}}
Ricordiamo che abbiamo detto che nelle API Posix non c'è la terminazione a cascata.
\begin{description}
    \item[P. zombie:] Se un processo termina ma il suo padre non lo sta aspettando (non ha invocato \texttt{wait()}) il processo è detto essere \textbf{\textit{zombie}}.\\
    Praticamente il processo ritorna un codice di errore ma non c'è nessuno a prendere e gestire il codice di errore. Il processo viene allora riallocato ma il codice rimane, quindi il processo non è effettivamente morto. Per questo \textit{zombie}.
    \item[P. orfano:] Se un processo padre termina \underline{prima} di un suo figlio, il figlio è detto essere \textbf{\textit{orfano}} (non vi è terminazione a cascata).
\end{description}

\section{Implementazione dei processi}
\subsection{Struttura di un processo}
Un processo è composto da diverse parti:
\begin{itemize}
    \item Lo stato dei registri del processore che esegue il programma, incluso il program counter.
    \item Lo stato della regione di memoria centrale usata dal programma, o \textbf{immagine} del processo.
    \item Lo stato del processo stesso.
    \item Le risorse del sistema operativo in uso al programma (files, semafori, regioni di memoria condivisa\dots).
\end{itemize}
\textit{Processi distinti} hanno \textit{immagini distinte}.\\
Le risorse del sistema operativo invece possono essere condivise tra processi (a seconda del tipo di risorsa).

\subsubsection{Immagine di un processo}
\begin{center}
    \includegraphics[width=90mm]{images/aa2324/SO_implementazioneprocessi1.jpg}
\end{center}
L'immagine di un processo è formata da:
\begin{itemize}
    \item Il codice del programma (\textbf{text section})
    \item La \textbf{data section}, contenente le variabili globali
    \item Lo \textbf{heap}, contenente la memoria allocata dinamicamente durante l'esecuzione
    \item Lo stack delle chiamate, contenente parametri, variabili locali e indirizzo di ritorno
\end{itemize}
\textit{Text} e \textit{data section} hanno dimensioni costanti per tutta la vita del processo.\\
\textit{Stack} e \textit{heap} invece crescono/decrescono durante la vita del processo, smetteranno solo quando una delle due sezioni raggiungerà la fine della memoria allocata per il processo, ovvero collidono tra loro.
%  0:06:40 su 1:20:44 seconda lezione 












