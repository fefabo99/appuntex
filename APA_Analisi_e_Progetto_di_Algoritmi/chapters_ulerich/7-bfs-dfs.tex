\chapter{Breadth First Search - BFS}
Visita in ampiezza di un grafo non orientato
\section{Introduzione Concetti}
\subsection*{Distanza tra due vertici}
$G=(V,E) \rt$ grafo non orientato con insieme V dei vertici e insieme E degli archi.\\
\textbf{Distanza} di u da v \ra minimo numero di archi da percorrere per andare da v a u.
\paragraph*{Esempio} Distanza di 3 da 4 = 2
\begin{center}
    \includegraphics[width=80mm, scale=0.5]{bfs-esempio-pesi.png}
\end{center}
In poche parole è come se ogni arco avesse peso 1.
\subsection*{BFS(G,s) - Visita in ampiezza}
Significa effettuare la visita di un grafo \textbf{non} orientato G, a partire da un vertice
sorgente s:
\begin{itemize}
    \item All'inizio viene visitata la sorgente s
    \item Vengono poi visitati uno dopo l'altro tutti gli adiacenti di S
    \item In seguito, per ogni adiacente v di s, vengono visitati uno dopo l'altro
    gli adiacenti di v non ancora visitati
    \item Si prosegue a visitare gli adiacenti degli adiacenti e via di seguito
\end{itemize}
Tradotto in un esempio pratico:
\begin{itemize}
    \item Viene visitato s
    \item Vengono visitati tutti i vertici a distanza 1 da s
    \item Vengono visitati tutti i vertici a distanza 2 da s
    \item Vengono visitati tutti i vertici a distanza 3 da s
    \item etc.
\end{itemize}
\subsection{Caratteristiche di BFS}
\begin{itemize}
    \item Visita tutti e i soli vertici raggiungibili da s (vedremo che per DFS non sarà così)
    \item Ogni vertice del grafo viene visitato al più una volta
    \item Permette di trovare la distanza (in archi) da s di tutti i vertici
    raggiungibili dalla sorgente
\end{itemize}
\section{Colore Vertici}
I vertici hanno associato un colore:
\begin{itemize}
    \item vertice \underline{bianco} \ra vertice non visitato
    \item vertice \underline{grigio} \ra vertice visitato (adiacenti non
    completamente visitati)
    \item vertice \underline{nero} \ra vertice visitato (adiacenti completamente visitati)
\end{itemize}
\section{Esempio Esecuzione BFS}
BFS(G, A), in questo modo identifico che la sorgente è A, quindi inizio da A.
\begin{center}
    \includegraphics[width=80mm,scale=0.5]{bfs_esec1.png}
\end{center}
Controllo quali sono i nodi adiacenti ad A e $adj(A)=B,C,E$.\\
Parto da B, percorro l'arco e per segnare che ho percorso l'arco per esplorare B 
faccio diventare l'arco più spesso, inserisco B come risultato del BFS.
\begin{center}
    \includegraphics[width=80mm,scale=0.5]{bfs_esec2.png}
\end{center}
I vertici verdi indicano che la distanza dalla sorgente è 1.\\
Dopo aver visitato B, proseguo al secondo adiacente C, l'arco A-C diventa spesso 
perchè è stato percorso per scoprire C, inserisco C nella soluzione.\\
Passo ad E e faccio la stessa cosa.
\paragraph*{Coloro A di nero} Tutti gli adiacenti di A sono grigi (sono stati visitati), quindi
A diventa nero.
\paragraph*{Analizzo gli adiacenti di B}
\begin{center}
    \includegraphics[width=80mm,scale=0.5]{bfs_esec3.png}
\end{center}
Osservo che gli adiacenti sono \ra $adj(B) = D,F,C,A$.\\
Analizzo D, noto che non è stato ancora esplorato (è bianco), quindi lo coloro di grigio e
faccio diventare l'arco B-D spesso. Coloro di Giallo il vertice D per indicare distanza 2 dalla
sorgente.\\
Lo stesso per F.\\
C lo ignoro perchè è stato già esplorato in precedenza.\\
A lo ignoro perchè è nero, quindi è già completo.\\
Notiamo che gli adiacenti di B sono tutti grigi, quindi B diventa nero.
\begin{center}
    \includegraphics[width=80mm,scale=0.5]{bfs_esec4.png}
\end{center}
\paragraph*{Analizzo gli adiacenti a C} \ra $adj(C) = B,F,E,A$.\\
B lo ignoriamo perchè è nero.\\
F lo ignoriamo perchè è grigio.\\
E lo ignoriamo perchè è grigio.\\
A lo ignoriamo perchè è nero.
Tutti i vertici di C sono stati esplorati, C \ra nero.
\paragraph*{Analizzo gli adiacenti a E} \ra $adj(E) = A,C,F$.\\
A lo ignoro perchè è nero.\\
C lo ignoro perchè è nero.\\
F lo ignoro perchè è grigio.\\
Tutti i vertici di E sono stati esplorati, E \ra nero.
\paragraph*{Analizzo gli adiacenti di D} \ra $adj(D) = B, F$.\\
B lo ignoro perchè è nero.\\
F lo ignoro perchè è grigio.\\
Tutti i vertici di D sono stati esplorati, D \ra nero.
\paragraph*{Analizzo gli adiacenti a F} \ra $adj(F) = B,D,C,E$.\\
Tutti i vertici adiacenti sono neri.\\
Tutti i vertici di F sono stati esplorati, F \ra nero.
\begin{center}
    \includegraphics[width=80mm,scale=0.5]{bfs_esec5.png}
\end{center}
Questo è il risultato finale, notiamo che G e H, non sono stati esplorati, infatti sono bianchi.\\
Questo perchè BFS visita solo archi gli archi connessi alla sorgente.\\
A predecessore di B,C,E.\\
B predecessore di D,F.\\
Con questi dati otteniamo \textbf{l'Albero della BFS}:
\begin{center}
    \includegraphics[width=80mm,scale=0.4]{bfs_albero.png}
\end{center}
\section{Strutture di base della BFS}
\begin{itemize}
    \item color \ra vettore dei colori
    \item d \ra vettore delle distanze
    \item $\pi$ \ra vettore dei predecessori
\end{itemize}
\subsection*{Vettore dei colori di lunghezza $|V|$}
color[v]:
\begin{itemize}
    \item W (bianco) \ra vertice non visitato
    \item G (grigio) \ra vertice visitato (ma non tutti gli adiacenti sono già
    stati ispezionati)
    \item B (nero) \ra vertice visitato (con tutti gli adiacenti visitati)
\end{itemize}
\paragraph*{Prima e Dopo la visita}
\begin{itemize}
    \item Prima della visita \ra color[v] = W per ogni vertice v
    \item Dopo la visita \ra color[v] = W per ogni vertice v non visitato
    \item Dopo la visita \ra color[v] = B per ogni vertice v visitato
\end{itemize}
\paragraph*{Durante la visita} un vertice v che ha ancora adiacenti da ispezionare è
di colore G. Nessun vertice ha colore G prima e dopo la visita.
\subsection*{Vettore delle distanze di lunghezza $|V|$}
d[v] \ra distanza di v dalla sorgente s.
\begin{itemize}
    \item Prima delle visita \ra $d[v] = \infty$ per ogni v diverso da s.
    \item Per la sorgente \ra $d[s] = 0$.
    \item Dopo la visita \ra $d[v] = \infty$ per ogni v non visitato.
    \item Dopo la visita \ra $d[v] = n$ per ogni v visitato distante n archi da s
\end{itemize}
\subsection*{Vettore dei predecessori di lunghezza $|V|$}
$\pi[v]=u$ \ra predecessore di v nella visita (si ha $(u,v)\in E$).
\begin{itemize}
    \item prima delle visita \ra $\pi[v] = NIL$ per ogni v
    \item dopo la visita \ra $\pi[s] = NIL$
    \item dopo la visita \ra $\pi[v] = NIL$ per ogni $v (\neq s)$ non visitato
\end{itemize}
\begin{box_giallochiaro}
    {color[v] = W dopo la visita $\implies d[v] = \infty$ e $\pi[v]=NIL$}.
\end{box_giallochiaro}
\subsection{BFS utilizza una coda Q}
\begin{itemize}
    \item Un vertice viene inserito in Q non appena viene visitato
    \item Un vertive visitato rimane in Q finchè non viene estratto per esplorare
    i suoi adiacenti
    \item Quando tutti gli adiacenti di un vertie risultano visistati, il vertice
    diventa nero
    \item la visita termina quando Q è vuota
\end{itemize}
Q contiene solo i vertici grigi!
\section{Operazioni sulla coda Q}
\begin{itemize}
    \item \textbf{head(Q)} restituisce il vertice in testa
    \item \textbf{enqueue(Q, v)}, inserisce il vertice v in coda
    \item \textbf{dequeue(Q)}, elimina il vertice in testa
\end{itemize}
\section{Codice}
\begin{lstlisting}[language=Java, escapeinside={!"}{"!}]
    Procedura_BFS(G, s)
        foreach v !"$\in$"! V \ {s} do
            color[v] = W, d[v] = !"$\infty,\, \pi[v]$"! = NIL
        color[s] = G, d[s] = 0, !"$\pi$"![s] = NIL
        Q = !"$\emptyset$"!
        enqueue(Q,s)
        while Q is not !"$\emptyset$"! do
            v = head(Q)
            foreach u !"$\in$"! adj(v) do
                if color[u] is W then
                    color[u] = G
                    enqueue(Q,u)
                    d[u] = d[v]+1
                    !"$\pi$"![u] = v
            color[v] = B
            dequeue(Q)
\end{lstlisting}
\subsection{Esempio esecuzione algoritmo BFS}
Nella slide 109 di BFS è riportata l'esecuzione passo per passo dell'algoritmo con
i valori di distanza e di colore per ogni vertice, riportando la variazione
passo per passo.\\
Risulta ancora più evidente che la coda contiene solo vertici grigi, dato che vengono inseriti
quando vengono scoperti e rimossi solo quando diventano neri.\\
La differenza con l'esecuzione grafica è che qua chiaramente al posto dei colori ci saranno le distanze
salvate nelle tabelle e il predecessore, quindi quando scopro un nuovo vertice
devo incrementare la distanza di 1 e aggiungere il vertice che sto analizzando 
(quello prelevato dalla coda tramite la head) come predecessore del vertice adiacente che
sto considerando (quello dentro il foreach).\\
Vediamo che grazie alla coda riusciamo a mantenere in memoria tutti i vertici grigi
e mano a mano che finiamo di analizzare i vertici effettuiamo la dequeue, quindi
quando la coda sarà vuota l'algoritmo termina.
\paragraph*{Alla fine dell'esecuzione avremo la seguente tabella}
\begin{center}
    \includegraphics[width=80mm,scale=0.5]{bfs_tabella.png}
\end{center}
Per calcolare il il BFS Tree è sufficiente guardare quali sono i predecessori nella tabella,
questi sono i collegamenti che determinano l'albero di esplorazione BFS.
\subsection{BFS Tree}
$T = (V_T, E_T)$:
\begin{itemize}
    \item $V_T = \{v \in V | color[v] = B\}$
    \item $E_T = \{(\pi[v], v) | v \in V_T\}$
\end{itemize}
\subsection{Complessità in tempo}
$|V| \rt$ numero dei vertici del grafo.\\
$|E| \rt$ numero archi ndel grafo.--redirect-gateway def1
\begin{itemize}
    \item Costo di inizializzazione \ra $O(|V|)$
    \item Singola operazione su Q \ra tempo costante
    \item un vertice viene aggiunto a Q al più una volta
    \item un vertice viene estratto da Q al più una volta
    \item Ogni lista di adiacenza viene ispezionata quado il vertice viene estratto da Q
    (al più una volta)
    \item Dimebnsione totale delle liste di adiacenza \ra $2|E|$
    \item Costo di ispezioni delle liste di adiacenza \ra $O(|E|)$
\end{itemize}
\paragraph*{Complessità nel caso peggiore} $O(|V|+|E|)$
\section{Esercizi}
Sono stati proposti una serie di esercizi che richiedono l'utlizzo di BFS, per
esempio:
\paragraph*{Verificare se un grafo G=(V,E) è connesso}
\begin{lstlisting}[language=Java, escapeinside={!"}{"!}]
    Procedura Is_connected(G)
        u = randm vertex from V
        BFS(G,u)
        foreach v !"$\in$"! V do
            if colour[v] is W then
                return false
        return true
\end{lstlisting}

\chapter{Depth First Search (DFS)}
