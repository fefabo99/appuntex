\chapter{Minimum Spanning Tree - MST}
\paragraph*{INPUT}: Grafo connesso non orientato pesato $G=(V,E)$ con:\\
$W:E \rt R^+$ tale che $W(u,v)$ è il peso dell'arco (u,v).
\paragraph*{OUTPUT}: $T \subseteq E$ aciclico tale che:
\begin{enumerate}
    \item $\forall v \in V, \exists (u,v) \in T$
    \item $W(T) = \sum_{(u,v)\in T} W(u,v)$ è minimo
\end{enumerate}
$G_T = (V,T) \rt$ Minimum Spanning Tree (MST).
\begin{center}
    \includegraphics[width=80mm,scale=0.5]{minimum_spanning_tree.png}
\end{center}
$W(T)=37$
\section{Soluzione Generica}
\paragraph*{Algoritmo Generico}
\begin{enumerate}
    \item Inizializza un insieme A vuoto
    \item Aggiunge ad ogni passo un arco (u,v) in modo tale che $A \cup \{(u,v)\}$
    è sottoinsieme dell'insieme T degli archi MST
    \item L'algoritmo termina non appena $A=T$ (cioè, $G_A=(V,T)$ è MST)
\end{enumerate}
$(u,v)$ \ra arco sicuro per A (cioè appartiene a MST)
\begin{lstlisting}[language=Java, escapeinside={@*}{*@}]
    Procedura Generic_MST(G,W)
        A = @*\empt*@
        while @*$G_A = (V,A) \neq$*@ MST do
            trova arco (u,v) sicuro per A
            A = A @*$\cup$*@ {(u,v)}
        return A
\end{lstlisting}
\section{Definizioni Principali}
\subsection{Taglio}
\definizione{Definizione di Taglio: Partizione di V in due insiemi $V'$ e $V-V'$}
\subsection{Arco che Attraversa il Taglio}
\definizione{Definizione di Arco che \underline{Attraversa} il Taglio: arco $(u,v) \in E$ tale che u appartiene a $V'$ e v 
appartiene a $V'-V$} 
\paragraph*{Esempio di Taglio}
\begin{center}
    \includegraphics[width=80mm,scale=0.5]{mst_taglio.png}
\end{center}
$V' = \{1,2,3,5,6\}$\\
$V'-V=\{4,7,8,9\}$\\
\subsection{Taglio che rispetta un insieme}
\definizione{Un taglio che \underline{rispetta} un insieme $A \subseteq E$, se nessun arco di A
attraversa il taglio}
\begin{center}
    \includegraphics[width=80mm,scale=0.5]{mst_taglio_rispetta.png}
\end{center}
Il taglio rispetta $A = \{(1,2),(2,3),(3,6),(7,8),(8,9)\}$.
\subsection{Arco Leggero}
\definizione{Arco di peso minimo che attraversa il taglio}
\begin{center}
    \includegraphics[width=80mm,scale=0.5]{mst_taglio_leggero.png}
\end{center}
(4,2) \ra arco \underline{leggero}
\section{Teorema dell'arco sicuro}
Dati un grafo connesso non orientato e pesato $G=(V,E)$, un sottoinsieme A dell'insieme T di archi di un
Minimum Spanning Tree (MST) e un qualsiasi taglio che rispetti A, allora un arco leggero (u,v) del taglio è
sicuro per A, cioè $A \cup \{(u,v)\} \subseteq T$.
\subsection{Proof}
Considero T \ra insieme di archi di un MST.\\
$A \subseteq T \rt$ sottoinsieme di T.\\
Taglio che rispetta A = (\tikz \fill[green] (0,0) circle (2pt);, \tikz \fill[blue] (0,0) circle (2pt);).\\
$(u,v) \rt$ arco leggero del taglio.
\begin{center}
    \includegraphics[width=80mm,scale=0.5]{arco_sicuro_dim_mst.png}
\end{center}
Il peso $W(u,v)$ è sicuramente $\leq$ rispetto al peso $W(x,y)$.\\
Sostituisco $(x,y)$, con $(u,v)$ e inserisco quindi l'arco $(u,v)$ all'interno
del grafo e noto che il grafo resta comunque un albero, vedo che resta un MST dato
che non ci sono cicli, ottengo quindi $T'$ con $W(T') \leq W(T)$.\\
\begin{center}
    \includegraphics[width=80mm,scale=0.5]{arco_sicuro_dim_mst_2.png}
\end{center}
Per ipotesi, $A \subseteq T$ non contiene $(u,v)$ e $(x,y)$ e per costruzione $T'$ 
non contiene $(x,y)$.\\
$\implies A \subseteq T'$\\
$A \cup \{(u,v)\} \subseteq T'$
\subsection{Esempio Teorema}
Dato il seguente sottoinsieme di T denominato $A = \{archi blu\} \subseteq T$, prendiamo\\
l'arco (2,4) \ra che è arco leggero (dato che ha peso 2), posiamo dire che è un arco sicuro,
infatti se guardiamo T notiamo che $A \cup \{(2,4)\} \subseteq T$, infatti l'arco appartiene
all'MST T.
\begin{center}
    \includegraphics[width=80mm,scale=0.5]{arco_sicuro_es.png}
\end{center}
\subsection{Soluzione generica}
\begin{lstlisting}[language=Java, escapeinside={@*}{*@}]
    Procedura Generic_MST(G,W)
        A = @*\empt*@
        while @*$|V|-|A|>1$*@ do
            trova arco (u,v) sicuro per A
            A = A @*$\cup$*@ {(u,v)}
        return A
\end{lstlisting}
\begin{enumerate}
    \item A rimane aciclico durante le iterazioni
    \item $G_A = (V,A)$ (ad ogni iterazione) è una foresta di $|V|-|A|$ alberi
    \item All'inizio $G_A$ contiene $|V|$ alberti (i singoli vertici)
    \item Ogni iterazione riduce di 1 il numero di alberi e l'arco sicuro (u,v) collega
    sempre componenti distinte di $G_A$
    \item Quando si arriva a un solo albero l'algoritmo termina
    \item Il numero di iterazioni è pari a $|V|-1$
\end{enumerate}
\subsection{COROLLARIO}
$A\subseteq T$ è tale che $G_A = (V,A)$ è una foresta di $|V|-|A|$ alberi.\\
Sia $C= (V_C, A_C), V_C \subseteq V$ e $A_C \subseteq A$, una componente connessa di $G_A$\\
$\implies (V_C, V-V_C)$ è sicuramente un taglio che \underline{rispetta} A\\
$\implies$ un arco leggero di $(V_C, V-V_C)$ è arco \underline{sicuro} per A.\\
\paragraph*{QUINDI} Ad ogni iterazione, per aggiungere ad A un arco sicuro (arco di MST) basta:
\begin{enumerate}
    \item Considerare una delle componenti C della foresta $G_A = (V,A)$
    \item Trovare l'arco di peso minimo che collega un vertice in C con un vertice non in C
\end{enumerate}
\begin{center}
    \includegraphics[width=80mm,scale=0.5]{arco_sicuro_corollario.png}
\end{center}
\paragraph*{Corollario} Dati un grafo connesso non orientato e pesato G = (V,E), un
sottoinsieme A degli archi di MST, una componente connessa $C = (V_C, E_C)$ di $G_A = (V,A)$,
allora un arco leggero (u,v) del taglio $(V_C, V-V_C)$ è un arco \underline{sicuro} per A.
\subsection{Implementazione GENERIC-MST}
Ci sono principalmente due implementazioni di GENERIC-MST e sono 2 algoritmi:
\begin{itemize}
    \item Algoritmo di Kruskal
    \item Algoritmo di Prim
\end{itemize}
\section{Algoritmo di Kruskal}
\textbf{MST = Sottoinsieme ottimo di un matroide grafico $M_G$}.
$M_G = (S,F)$ per $G=(V,E,W)$ non orientato e connesso:
\begin{itemize}
    \item S, insieme E degli archi di G
    \item F, tutti i sottoinsiemi di S che sono aciclici
\end{itemize}
pesato con:\\
$W:S \rt R^+$ tale che $W(s)$ è il peso dell'arco s.\\
Sottoinsieme ottimo di $M_G$ pesato con W\\
\ra Archi dello Spanning Tree (ST) di peso massimo.\\
$W':S \rt R^+$ tale che $W'(s) = W_0 - W(s)$\\
$W_0$ è il massimo valore del peso degli archi (massimo per W)\\
Sottoinsieme ottimo di $M_G$ pesato con $W'$\\
\ra Sottoinsieme masimale di peso massimo (per $W'$) e di peso minimo per W che equivale a dire:\\
\ra Archi dello Spanning Tree (ST) di peso \underline{minimo}, cioè l'MST.
\subsection{Algoritmo Greedy Standard per il matroide grafico}.
\begin{lstlisting}[language=Java, escapeinside={@*}{*@}]
    Procedura Generic_matroid_grafic(E = @*$\{e_1, e_2, ..., e_n\}$*@)
        X = @*$\emptyset$*@
        Ordino E per peso W crescente (non decrescente)
        for i form 1 to n do
            if @*$e_i$*@ arco sicuro then
                A = @*$\{e_i\} \cup A $*@
        return A
\end{lstlisting}
\subsection{Algoritmo Kruskal}
\begin{lstlisting}[language=Java, escapeinside={@*}{*@}]
    Procedura KRUSKAL_MST(G = (V,E), W)
        A = @*$\emptyset$*@
        E = @*$\langle e_1, e_2, ..., e_n \rangle$*@ ordinati per peso crescente (non decr.)
        for i form 1 to n do
            if @*$\{e_i\} \cup A \subseteq T$*@ then
                A = @*$\{e_i\} \cup A $*@
        return A
\end{lstlisting}
Devo tradurre in codice l'if che determina se $e_i$ è un arco sicuro e per fare questo
\textbf{applico il corollario}:\\
$e_i = (u,v)$ è arco sicuro se è un arco di peso minimo che connette un vertice di una componente C
con un vertice che non è in C. Quindi $e_i$ è arco sicuro se connette due componenti diverse
di $G_A = (V,A)$. Quindi basta asssegnare l'arco che sto analizzando $e_i$ a $(u,v)$ e se
non appartengono alla stessa componente di $G_A(V,A)$, allora posso aggiungere l'arco alla soluzione A.
\begin{lstlisting}[language=Java, escapeinside={@*}{*@}]
    Procedura KRUSKAL_MST(G = (V,E), W)
        A = @*$\emptyset$*@
        E = @*$\langle e_1, e_2, ..., e_n \rangle$*@ ordinati per peso crescente (non decr.)
        for i form 1 to n do
            (u,v) = @*$e_i$*@
            if u e v @*$\notin$*@ stessa componente di @*$G_A(V,A)$*@ then
                A = @*$\{(u,v)\} \cup A $*@
        return A
\end{lstlisting}