\chapter{Introduzione algoritmi}
\section{Che cos'è un algoritmo?}
Un algoritmo è
\begin{itemize}
    \item Una sequenza di istruzioni elementari 
    \item Agisce su un input per produrre un output
    \item Risolve un problema computazionale
\end{itemize}

Un algoritmo deve essere corretto e efficiente.

\paragraph{Corretto} Significa che deve funzionare per qualsiasi input valido
\paragraph{Efficiente} Deve occupare il minor spazio possibile ed impiegare il minor tempo possibile.

L'efficienza di un algoritmo si misura in termini di spazio e tempo

\section{Analisi di un algoritmo}
Per analizzare l'efficienza di un algoritmo si calcola il numero di istruzioni eseguite, ma esso non è univoco, varia in base all'input ricevuto, 
è quindi necessario individuare il \textbf{caso migliore} e il \textbf{caso peggiore}, essi si analizzano a parità di dimensioni, per questo non dipendono da essa.
Dire che il caso migliore è quando l'array è vuoto non ha senso ai fini dell'analisi.

Per avere un'idea dei tempi di esecuzione è necessario calcolare il \textbf{Caso Medio}
\paragraph{NON è la media tra caso peggiore e caso migliore!}

\section{Regole sullo Pseudocodice}
Gli algoritmi saranno scritti in Pseudocodice secondo le seguenti regole
\begin{itemize}
    \item Il codice sarà simil C/Java
    \item Cicli: for, while, do-while
    \item Condizioni: if, else
    \item Indentazione + begin/end
    \item Commenti /*.......*/
    \item Assegnamenti A = 5, A := 5, A $\leftarrow$ 5
    \item Test del valore A == 5
    \item Variabili: locali
    \item Array A[i] $\rightarrow$ i $\rightarrow$ 1 \dots n
    \item Gli Array partono da 1
    \item Dati sono considerati oggetti con attrivuti (come length(A) per gli array)
    \item Puntatori: liste dinamiche
    \item Funzioni/Procedure - I parametri sono passati per valore (non per indirizzo)
\end{itemize}

\paragraph{Macchina RAM (Random Access Machine)}
La macchina su cui verranno eseguiti gli algoritmi sarà considerata RAM e quindi con le seguenti Caratteristiche
\begin{itemize}
    \item Memoria ad accesso diretto
    \item No limiti memoria
    \item Sistema monoprocessore
\end{itemize}

\section{Esame}
L'esame sarà uno scritto con esercizi e domande di teoria. 
I parziali sono tendenzialmente riservati al primo anno, ma è possibile scrivere una email al prof 2 settimane prima del parziale e chiedere di poterlo sostenere
anche se si è di un altro anno, sarà a sua discrezione concedere o meno questa opportunità.
Si possono recuperare i parziali, è possibile anche tentare un recupero per migliorare un voto già positivo, accettando il rischio di
che se il voto preso nell'esame di recupero è minore di quello originale si dovrà accettare quel voto.

\section{Definizioni di base}
\paragraph*{Algoritmo Corretto} Un algoritmo si definisce corretto se per tutti gli input si ottiene il 
risultato desiderato, l'algoritmo è corretto solo se garantisce la correttezza del risultato.
\paragraph*{Algoritmo efficiente} Minor utilizzo di \textbf{Spazio} e \textbf{Tempo}.

\subsection*{Determinare l'efficienza di un algoritmo}
Il primo passo è determinare il numero di istruzioni eseguite dall'algoritmo
dato che così facendo non dipendo dalla potenza dell'hardware
e dall'input.
\paragraph*{Operazioni valutazione algoritmo}
\begin{enumerate}
    \item Conto le istruzioni \textbf{eseguite}
    \item Determinare T peggiore - T migliore - T medio (la media non è fra
    T peggiore e T migliore)
\end{enumerate}
Il tempo non sarà una quantità in secondi, ma dipenderanno da un parametro
n T(n).
\\ Quando devo scegliere un algoritmo mi baso sulla funzione n, dato che al crescere
dell'input la funzione crescerà in modo lineare, quadratico, cubico, ecc. e 
questo mi mostrerà come cresce il tempo in funzione di n.
\\ A parità di n controllo il fattore moltiplicativo.
\paragraph*{Esempio} I polinimoniali hanno tempi di esecuzione accettabili,
mentre i tempi esponenziali sono intrattabili, il problema è che esistono algoritmi esatti,
ma sono esponenziali, per questo sono inutili dato che non con grandi input non
si fermano mai.
\\ Determinare il \textbf{Caso peggiore} serve per capire quanto tempo devo aspettare
al massimo, quindi dopo quanto tempo avrò sicuramente un risultato, il \textbf{Caso minore},
determina il tempo minimo che devo aspettare, il \textbf{Caso medio} determina mediamente
quanto tempo devo aspettare (non è la media fra T peggiore e T migliore).
\section{Ricerca Sequenziale}
\begin{lstlisting}[language=Java]
    int RicSeq(int k, int v[])
     1  i=1
        while v[i] != k AND i <= length(v)
            i++
     1  if i <= length(v)
    1/0     return(i)
        else
    1/0     return(-1)
\end{lstlisting}
In questo semplice algoritmo per la ricerca sequenziale di un numero all'interno
di un array ci concentreremo sulla ricerca del caso peggiore e quello migliore.\\
Ricordiamo che il caso peggiore e migliore si determina a parità di dimensione dell'input,
non ha senso dire che il caso migliore è il vettore vuoto.\\
I numeri a fianco indicano il numero di volte per cui ogni operazione è eseguita.
Else non viene considerato dato che non viene effettuato un controllo, quando l'if è falso rimanda
alle istruzioni sotto l'else (a livello di linguaggio macchina è un'etichetta che indica al codice
dove effettuare la jump nel caso in cui la condizione dell'if non fosse vera).
\subsection{Cosa devo identificare}
Devo identificare:
\begin{itemize}
    \item Quando si verifica (in che condizioni)
    \item Il tempo di esecuzione
\end{itemize}
\paragraph*{Quando si verifica}
\paragraph*{Migliore} Indicato come \textbf{t}. Posso pensare (sempre intuitivamente) che il caso migliore è quando il numero
si trova nella prima posizione del vettore.\\
Effettivamente in questo caso il ciclo while non viene mai attuato (a parte la verifica della condizione)
\paragraph*{Peggiore} In questo caso devo identificare per quale input la ricerca sequenziale
performa peggio, intuitivamente posso pensare che il caso peggiore è quando il numero non è presente
nel vettore, dato che devo scorrere tutto il vettore.\\
Analizzando l'esecuzione di tutte le istruzioni posso confermare la mia ipotesi.\\
\paragraph*{Importante} Non basta fare un esempio, per identificare il caso migliore e peggiore,
devo descrivere (anche in forma verbale) per quali input si verifica, in questo caso abbiamo detto infatti, quando
il numero non è presente oppure quando il numero si trova nella prima posizione.
\paragraph*{Analisi tempo di esecuzione} Il tempo di esecuzione dipende dal numero di operazioni
eseguite, i tempi di esecuzioni maggiori si concentrano spesso nei cicli (for, while, do-while, ecc.),
ma è comunque importante valutare tutte le istruzioni.
\paragraph*{Tempo di esecuzione caso migliore} Indicato con $t(n)$ In questo caso vengono eseguite solamente 4 istruzioni
\begin{lstlisting}[language=Java]
    int RicSeq(int k, int v[])
     1  i=1
     1  while v[i] != k AND i <= length(v)
            i++
     1  if i <= length(v)
     1      return(i)
       else
     0      return(-1)
\end{lstlisting}
Le quattro istruzioni con dei commenti
\begin{itemize}
    \item i=1
    \item while (controlla una volta sola dato che trova subito che k = v[i])
    \item if i $\leq$ length(v) 
    \item return(i)
\end{itemize}
Si tratta di una funzione costante $t(n) = 4$, solitamente le funzioni riguardanti i tempi
di esecuzione sono in funzione di n, ma in questo specifico caso la funzione non dipende
dalla dimensione dell'input, infatti se il numero è all'inizio del vettore a prescindere dalle
dimensioni dell'array non dovrò mai scorrere il vettore (vedremo che non è praticamente mai così per
il caso peggiore)
\paragraph*{Analisi esecuzione caso peggiore} Indicato con $T(n)$
\begin{lstlisting}[language=Java]
    int RicSeq(int k, int v[])
     1  i=1
    n+1 while v[i] != k AND i <= length(v)
     n       i++
     1  if i <= length(v)
     0      return(i)
       else
     1      return(-1)
\end{lstlisting}
Il ciclo while viene eseguito n+1 volte dato che ogni volta che incremento i++, devo
verificare di non essere uscito dall'array, quindi verrà eseguito sempre una volta in più
rispetto all'incremento.\\
Questo significa che $T(n) = 3 + 1 +2n = 2n + 4$ dove n è la dimensione dell'input, in
questo caso la dimensione dell'array.\\
Questa funzione indica il numero di istruzioni eseguite (non è propriamente un tempo).\\
\subsection{Caso medio}
Indicato come \textbf{$T_m(n)$}, è il tempo medio di esecuzione, non è la media fra il caso migliore e peggiore.\\
In questo caso dobbiamo chiederci, cosa ci aspettiamo che succeda mediamente?\\ In questo caso
mi aspetto che il caso medio sia che k si trovi in posizione $\frac{n}{2}$, quindi che sia a metà. Mi
aspetto quindi che il caso medio sia il caso peggiore diviso due.\\
In generale il caso medio è un po' più complesso dato che richiederebbe di conoscere la distribuzione
di probabilità dell'input.\\
$T_m(n)=2\frac{n}{2}+4=n+4$\\
\paragraph*{Possibile obiezione} Sto mettendo sullo stesso piano le istruzioni if e i while
che magari hanno più condizioni da verificare, effettivamente il while impiega leggermente
più tempo, posso scrivere una funzione indicando con c ($c_1, c_2, c_3, \dots$) il tempo di
esecuzione che può avere ogni istruzioni, il problema è che la funzione diventa enorme e poco
comprensibile, alla fine a me interessa capire l'ordine di grandezza di esecuzione per poter
capire se l'algoritmo è efficiente e per poterlo confrontare con altri algoritmi, alla fine
se confronto un algoritmo che ha come caso medio $1000n$ con uno che ha come caso medio $n^2$
sceglierò comunque il primo, quindi non mi interessa se alcune funzioni ci mettono un po' di più di
altre.

\section{Ricerca binaria (o dicotomica)}
La ricerca binaria si basa sull'assunzione che l'array dato in input sia ordinato.\\
L'elemento da cercare viene confrontato ripetutamente con l'elemento al centro 
della struttura dati e, in base al risultato del confronto, 
viene ridotta la porzione di dati in cui si effettua la successiva ricerca. 
Questo processo viene ripetuto fino a quando l'elemento desiderato viene trovato o 
fino a quando la porzione di dati da esaminare diventa vuota.
\begin{lstlisting}[language=Java]
    int Ricerca_Binaria(int k, int v[])
        sx = 1;
        dx = length(v);
        m = (sx+dx) div 2; //divisione intera
        while (v[m] != k AND sx <= dx)
            if v[m] > k
                dx = m-1;
            else 
                sx = m+1;
            m = (sx+dx) div 2;
        if sx <= dx
            return(m);
        else
            return(-1);
\end{lstlisting}
\paragraph*{Ricerca e analisi caso migliore} Il caso migliore è quando il numero da cercare k si trova
esattamente al centro dell'array, quindi in posizione $\frac{n}{2}$, dato che non entra mai nel ciclo.\\
Verifichiamo quante volte vengono eseguite le istruzioni:
\begin{lstlisting}[language=Java]
    int Ricerca_Binaria(int k, int v[])
    1   sx = 1;
    1   dx = length(v);
    1   m = (sx+dx) div 2; //divisione intera
    1   while (v[m] != k AND sx <= dx)
            if v[m] > k
                dx = m-1;
            else 
                sx = m+1;
            m = (sx+dx) div 2;
    1   if sx <= dx
    1       return(m);
        else
            return(-1);
\end{lstlisting}
In totale abbiamo $t(n) = 6$ istruzioni eseguite. Anche in questo caso il valore non
dipende da n perchè non dipende dalla dimensione del vettore, basta che l'elemento
si trovi al centro dell'array.
\paragraph*{Ricerca e analisi caso peggiore}
Qui il caso peggiore è quando k non è presente in v.\\
Verifichiamo quante volte vengono eseguite le istruzioni:
\begin{lstlisting}[language=Java]
    int Ricerca_Binaria(int k, int v[])
    1    sx = 1;
    1    dx = length(v);
    1    m = (sx+dx) div 2; //divisione intera
    tw+1 while (v[m] != k AND sx <= dx)
    tw       if v[m] > k
    ft           dx = m-1;
             else 
    ff           sx = m+1;
    tw       m = (sx+dx) div 2;
    1    if sx <= dx
             return(m);
         else
    1        return(-1);
\end{lstlisting}
Quante volte cicla il while? Dipende dall'input!\\
Indichiamo questo valore con $t_w$\\
Quante volte testo l'if nel while? Sempre $t_w$ volte.\\
Quante volte l'if risulta vero e quindi eseguo il codice nell'if? Anche qua dipende, quindi
indico questo valore con $t_{if}$, per l'else assegno $f_{if}$ (flase if).\\
Assegno $t_w$ anche per l'assegnazione di m.\\
\paragraph*{Semplificazioni per il calcolo del tempo}
Posso considerare il numero di esecuzioni dell'if e dell'else come una sola variabile, quindi sempre
$t_w$, in totale ho quindi $2t_w$ esecuzioni, all'iterno del while, mentre i controlli del
while sono $t_w +1$ (il +1 è per il controllo del while finale).\\
Ottengo quindi:
\begin{lstlisting}[language=Java]
    int Ricerca_Binaria(int k, int v[])
    1    sx = 1;
    1    dx = length(v);
    1    m = (sx+dx) div 2; //divisione intera
    tw+1 while (v[m] != k AND sx <= dx)
    2(tw)   if v[m] > k
                 dx = m-1;
             else 
                 sx = m+1;
    tw        m = (sx+dx) div 2;
    1    if sx <= dx
             return(m);
         else
    1        return(-1);
\end{lstlisting}
In totale avrò che $T(n) = 6 + 4t_w$\\
Ma $t_w$ quante volte viene eseguito? Dato che ogni volta l'array viene diviso in 2 parti 
ho la seguente progressione:
\begin{itemize}
    \item Passo 0 n
    \item Passo 1 $\frac{n}{2}$
    \item Passo 2 $\frac{n}{2^2}$
    \item Passo 3 $\frac{n}{2^3}$
    \item \dots
\end{itemize}
Questa è una tipica progressione logaritmica infatti avrò che $n = 2^r$ e quindi $r = log_2(n)$.
Quindi il tempo peggiore sarà $T(n) = 6 + 4log_2(n)$.
\paragraph*{Caso medio}
In questo caso mi aspetto che mediamente dovrà dividere metà delle volte l'array rispetto
al caso peggiore, quindi avrà $t_m(n) = 6 + 2log_2(n)$.
