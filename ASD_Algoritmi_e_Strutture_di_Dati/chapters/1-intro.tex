\chapter{Introduzione algoritmi}
\section{Che cos'è un algoritmo?}
Un algoritmo è
\begin{itemize}
    \item Una sequenza di istruzioni elementari 
    \item Agisce su un input per produrre un output
    \item Risolve un problema computazionale
\end{itemize}

Un algoritmo deve essere corretto e efficiente.

\paragraph{Corretto} Significa che deve funzionare per qualsiasi input valido
\paragraph{Efficiente} Deve occupare il minor spazio possibile ed impiegare il minor tempo possibile.

L'efficienza di un algoritmo si misura in termini di spazio e tempo

\section{Analisi di un algoritmo}
Per analizzare l'efficienza di un algoritmo si calcola il numero di istruzioni eseguite, ma esso non è univoco, varia in base all'input ricevuto, 
è quindi necessario individuare il \textbf{caso migliore} e il \textbf{caso peggiore}, essi si analizzano a parità di dimensioni, per questo non dipendono da essa.
Dire che il caso migliore è quando l'array è vuoto non ha senso ai fini dell'analisi.

Per avere un'idea dei tempi di esecuzione è necessario calcolare il \textbf{Caso Medio}
\paragraph{NON è la media tra caso peggiore e caso migliore!}

\section{Regole sullo Pseudocodice}
Gli algoritmi saranno scritti in Pseudocodice secondo le seguenti regole
\begin{itemize}
    \item Il codice sarà simil C/Java
    \item Cicli: for, while, do-while
    \item Condizioni: if, else
    \item Indentazione + begin/end
    \item Commenti /*.......*/
    \item Assegnamenti A = 5, A := 5, A $\leftarrow$ 5
    \item Test del valore A == 5
    \item Variabili: locali
    \item Array A[i] $\rightarrow$ i $\rightarrow$ 1 \dots n
    \item Dati sono considerati oggetti con attrivuti (come length(A) per gli array)
    \item Puntatori: liste dinamiche
    \item Funzioni/Procedure - I parametri sono passati per valore (non per indirizzo)
\end{itemize}

\paragraph{Macchina RAM (Random Access Machine)}
La macchina su cui verranno eseguiti gli algoritmi sarà considerata RAM e quindi con le seguenti Caratteristiche
\begin{itemize}
    \item Memoria ad accesso diretto
    \item No limiti memoria
    \item Sistema monoprocessore
\end{itemize}

\section{Esame}
L'esame sarà uno scritto con esercizi e domande di teoria. 
I parziali sono tendenzialmente riservati al primo anno, ma è possibile scrivere una email al prof 2 settimane prima del parziale e chiedere di poterlo sostenere
anche se si è di un altro anno, sarà a sua discrezione concedere o meno questa opportunità.
Si possono recuperare i parziali, è possibile anche tentare un recupero per migliorare un voto già positivo, accettando il rischio di
che se il voto preso nell'esame di recupero è minore di quello originale si dovrà accettare quel voto.

\section{Definizioni di base}
\paragraph*{Algoritmo Corretto} Un algoritmo si definisce corretto se per tutti gli input si ottiene il 
risultato desiderato, l'algoritmo è corretto solo se garantisce la correttezza del risultato.
\paragraph*{Algoritmo efficiente} Minor utilizzo di \textbf{Spazio} e \textbf{Tempo}.

\subsection*{Determinare l'efficienza di un algoritmo}
Il primo passo è determinare il numero di istruzioni eseguite dall'algoritmo
dato che così facendo non dipendo dalla potenza dell'hardware
e dall'input.
\paragraph*{Operazioni valutazione algoritmo}
\begin{enumerate}
    \item Conto le istruzioni \textbf{eseguite}
    \item Determinare T peggiore - T migliore - T medio (la media non è fra
    T peggiore e T migliore)
\end{enumerate}
Il tempo non sarà una quantità in secondi, ma dipenderanno da un parametro
n T(n).
\\ Quando devo scegliere un algoritmo mi baso sulla funzione n, dato che al crescere
dell'input la funzione crescerà in modo lineare, quadratico, cubico, ecc. e 
questo mi mostrerà come cresce il tempo in funzione di n.
\\ A parità di n controllo il fattore moltiplicativo.
\paragraph*{Esempio} I polinimoniali hanno tempi di esecuzione accettabili,
mentre i tempi esponenziali sono intrattabili, il problema è che esistono algoritmi esatti,
ma sono esponenziali, per questo sono inutili dato che non con grandi input non
si fermano mai.
\\ Determinare il \textbf{Caso peggiore} serve per capire quanto tempo devo aspettare
al massimo, quindi dopo quanto tempo avrò sicuramente un risultato, il \textbf{Caso minore},
determina il tempo minimo che devo aspettare, il \textbf{Caso medio} determina mediamente
quanto tempo devo aspettare (non è la media fra T peggiore e T migliore).
