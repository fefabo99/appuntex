\chapter{Strutture dati}
Il dato viene memorizzato fisicamente in bit 0/1, che possono corrispondere
ad acceso/spento, magnetizzato/non magnetizzato, ecc.\\
Esistono diverse strutture dati perchè in base all'utilizzo (es. scrivo tanto e leggo poco oppure
scrivo poche volte e cerco tante volte) serve creare una struttura ottimizzata per le
mie necessità.\\
Chiaramente memorizzare i dati in un'unica riga di bit risulterebbe particolarmente
scomodo e inefficiente, per questo i bit vengono aggregati nelle seguenti categorie:
\begin{itemize}
    \item Tpi di dati (int, char, ecc.)
    \item Aggregazioni di tipi di dati (Array - insieme di dati uguali, Record - insieme di dati diversi) 
\end{itemize}
\section{ADT}
Abstract Data Type ADT, è la sigla con cui vengono indicate le strutture dati.
\subsection{Operazioni base della struttura dati}
\begin{itemize}
    \item Insert(S x)
    \item Delete(S, x)
    \item Search(S, k) - Usa k dato che nella ricerca ha senso mettere una chiave da cercare, non
    ha senso richiedere di cercare un dato dandogli il dato stesso
    \item Min/Max(S) - Minimo o Massimo sull'intera struttura dati
    \item Predecessor/Successor(S,k) - Elemento appena prima di k (in termini di valore)
    \item x $\rightarrow$ nil/null - In caso di mancata risposta (es. cerco elemento che non c'è) viene restituito null
\end{itemize}
S indica la struttura dati, mentre
X, K indicano rispettivamente:
\begin{itemize}
    \item x(elemento) - Indica un dato completo (es. temperatura)
    \item k(key) - Identificativo del dato
\end{itemize}
\paragraph*{Delete} In realtà è un'operazione complessa composta da una Search (ricerca)
\paragraph*{Search} Cerca il dato in un indice k e restituisce x (puntatore al dato),
in generale infatti x sarà da intendersi come un puntatore a memoria.
\paragraph*{Update} Non è un'operazione base dato che è la composizione di una search, una delete e una
insert, però per comodità viene utilizzata per evitare di scrivere ogni volta le tre operazioni.
\paragraph*{Operazioni e struttura dati} Quando introduco una struttura dati devo implementare e ottimizzare le
operazioni di base.
\section{Array}
Allocazione statica di un'area di memoria dove ci sarà un'aggregazione di dati.
\subsection{Perchè l'Array richiede che venga data la dimensione da allocare?}
Perchè l'array ha necessità di riservare la memoria PRIMA che vengano salvati dei dati.\\
A volte me la cavo (es. salva le temperature dei mesi, alloco 31 valori e sono apposto), ma
per situazioni dove il dato è variabile è un problema perchè:
\begin{itemize}
    \item Se alloco tanta memoria per ogni variabile ci sarà sicuramente uno spreco
    per quelli piccoli e se quelli grandi sono pochi lo spreso sarà ancora maggiore
    \item Se alloco poca memoria non ci stanno i dati!
\end{itemize}
\paragraph*{Perchè usare gli array?}
Il vantaggio dell'allocazione statica è che mi permette di sapere dove sono i dati attraverso indici,
perchè in ogni casella avrò un indirizzo di memoria che la punta e se voglio avere la 100-esima casella,
mi basterà sommare 100 caselle al primo indirizzo dell'array e questo è un grosso vantaggio.
\paragraph*{Riassumendo}
\begin{itemize}
    \item Svantaggi - Occupano più spazio di quanto richiesto
    \item Vantaggio - Tempo in quanto che ogni dato richiede lo stesso tempo di accesso dato che
    l'accesso è \textbf{diretto}
\end{itemize}
\section{Liste Dinamiche}
Una lista dinamica, organizza i dati in maniera dinamica, contrapposte agli Array, 
dato che essi sono statici, cioè prima del loro utilizzo viene allocata una parte di
memoria ben definita e resta riservata per quella variabile staticamente (quindi è fisso).\\
La lista invece non ha questa necessità dato che quando ho bisogno di memoria ne richiedo
l'allocazione, quindi la memoria allocata varierà durante l'esecuzione.\\
La lista dinamica è realizzata nel seguente modo:\\
Ho delle celle che contenegono 2 valori, il valore memorizzata dalla cella e il puntatore della prossima cella.
La prima cella è una testa che punta il primo valore, la seconda cella contiene il valore 
e il puntatore alla terza cella e così via.\\
Se cancello una cella modifico il puntatore precedente per farlo puntare a quella successiva a quella
cancellata e così facendo risparmio spazio. Se voglio aggiungre valori aggiungo celle e puntatori.\\
Il problema è che il tempo di accesso ai dati sarà variabile, perchè se devo accedere al primo elemento
lo trovo subito, ma se devo accedere all'ultimo devo scorrere tutti i dati uno ad uno fino ad arrivare 
all'ultimo. Nelle liste dinamiche l'accesso \textbf{non è diretto}.
\paragraph*{Riassumendo}
\begin{itemize}
    \item Vantaggi - Spazio occupato, dato che occupo solo ciò che mi serve e posso ridurre o aumentare
    a runtime lo spazio utilizzato
    \item Tempo - Dato che il tempo di accesso è variabile, in quanto l'accesso non è diretto.
\end{itemize}
\section{Tipi di liste}
\begin{itemize}
    \item Lista dinamica semplice
\end{itemize}
\subsection{Lista dinamica semplice}
La lista dinamica semplice è composta da head[L] una testa che è un array contenente un puntatore
al primo elemento della lista.\\
Un puntatore è un indirizzo di memoria (in formato esadecimale).\\
Le celle di memoria contenegono n dati (n caselle), l'ultima casella solitamente denominata
\textbf{next} contiene il puntatore alla prossima casella, l'ultimo next contiene null.\\
Chiamiamo P=head[L] il puntatore alla prima casella (indirizzo di memoria), per selezionare 
l'elemento tramite puntatore utilizzo la seguente scrittura: P.variabile.\\
Per spostarmi nella casela successiva scrivo P=P.next, così facendo P punta la seconda casella,
se adesso quindi gli dirò P.variabile, P punterà la variabile della seconda cella.\\
All'ultima cella P=P.next sarà uguale a null, devo stare attento in questo momento perchè se provo
ad accedere ai dati significa che sto provando ad accedere a una casella null e questo generà
un brutto errore.\\
Le liste mal gestite possono creare altri errori molto ambigui, perchè se non cancello le caselle di
memoria utilizzata e le libero, qualcun altro le può puntare e quando scorro la lista vado a 
prelevare dei dati che non ho scritto io, che spesso sono cose che se vengono stampate non
hanno senso.\\
\paragraph*{Gestione liste} Uno svantaggio della lista è che devono essere gestite bene
perchè la loro mal gestione può provare grossi errori e incoerenze.
\paragraph*{Osservazione scorrimento liste semplici} Le liste così strutturate posso
scorrerle solo in avanti, non posso tornare indietro, quindi se sto cercando una casella da cancellare
mi devono fermare un passo prima.
\subsection{Lista dinamica doppia o doppiamente concatenata}
La lista dinamica doppia è strutturata come la lista semplice, ma nelle celle oltre 
al next ha anche il previous che è l'indirizzo della casella precedente, così posso
spostarmi anche all'indietro. In questo modo la cancellazione è più semplice.
\subsection{Liste circolari}
Qua l'ultimo P.next non è null, ma punta il primo elemento della lista così che la lista non
finisca mai, ma continui a girare e previous di head punta l'ultimo valore. Sia le liste
semplici che doppie possono essere trasformate in circolari. I tipi di liste
restano quindi sempre 2:
\begin{itemize}
    \item Semplice
    \item Doppia
\end{itemize}
\section{Implementazione Operazioni Lista}
\subsection{Search}
\begin{lstlisting}[language=Java]
    pointer Search(L,k)
        P=head[L]
        while P.key != k AND P != null
            P = P.next
        return(P)
\end{lstlisting}
\begin{itemize}
    \item L è l'indice della Lista
    \item P != null per evitare Null pointer exception
    \item return Null non è un problema, il problema è se facessi P.key con P=null, ma questo
    non può accadere per come abbiamo scritto il codice
\end{itemize}
\paragraph*{Caso migliore} k è nel primo elemento. $T(n)=\Omega(1)$
\paragraph*{Caso peggiore} $k \notin  L$ dato che devo scorrere tutta la lista.
$T(n) = O(n)$\\
\paragraph*{Tempo di esecuzione uguale ad array} In questo caso il tempo di esecuzione è uguale
agli array, ma se prendiamo per esempio la ricerca dicotomica vedremo che i tempi delle liste sono
peggio perchè è più dispendioso per una lista posizionarmi a uno specifico indice richiesto.\\
\subsection{Insert}
\begin{lstlisting}[language=Java]
    Insert(L,x)
        x.Prev = null
        x.Next = head[L]
        if head[L] != null
            head[L].Prev = x
        head[L] = x
\end{lstlisting}
Nello pseudocodice non è indicato, ma nella realtà devo preoccuparmi di allocare dello
spazio per la casella, calcolando quanto spazio mi serve, verificando quanto spazio
occupano tutte le variabili della casella. Questo si fa con funzioni del tipo size.
\paragraph*{Dove mi conviene inserire l'elemento?} Mi conviene inserirlo all'inizio
perchè se lo inserisco alla fine ogni volta richiedo n esecuzioni per scorrere tutta la lista, per
questo inserisco l'elemento in testa.
\paragraph*{Casi particolari da controllare} All'inizio dell'implementazione mi conviene pensare la
lista popolata, ma i casi particolari vanno trattati e sono:
\begin{itemize}
    \item Prima casella - Ha previous = null
    \item Lista vuota - Ha subito next = null
\end{itemize}
Devo stare attento a come manipolo la next, perchè rischio di perdere il collegamento
ai dati cancellando il next sbagliato o sovrascrivendolo e rischio di generare loop.
\paragraph*{Riassumendo} In una lista doppia mi è richiesto di cambiare 4 cambi, settare i
la prev di x, la next di x va agganciata a next, head[L].prev va aggiornata, e la nuova
head sarà x. L'If serve per controllare se la lista è vuota, dato che se è vuota il Prev non va
settato, altrimenti head[L] sarà l'x appena aggiunto.\\
Assumiamo che x sia un puntatore valido, altrimenti dovremmo fare il test (anche per verificare
che la sizeof sia andata a buon fine).
\subsection{Delete}
\begin{lstlisting}[language=Java]
    Delete(L,x)
        if x.prev != null
            (x.prev).next = x.next
        else
            head[L]=x.next
        if x.next != null
            (x.next).prev = x.prev
        /* Free(x) */
\end{lstlisting}
Assumiamo che la search dell'elemento da cercare sia stata già fatta.\\
Io devo cancellare la casella data in input e sistemare i puntatori della casella prima e di
quella successiva per agganciarli.\\
(x.Prev).next punta la next della casella prima.\\
(x.next).prev punta la prev della casella dopo.\\
Con queste due funzioni cancello la cella, ma la memoria di x resta allocata e non
più raggiungibile quindi a seconda del linguaggio di programmazione devo preoccuparmi
di liberare quella memoria.\\
Ora mi occupo dei casi particolari:
\begin{itemize}
    \item Cancellazone del primo elemento
    \item Cancellazione dell'ultimo elemento
\end{itemize}
Nel secondo if non c'è bisogno dell'else perchè se x.next = null allora
non devo fare nulla perchè è l'ultimo elemento della lista e quindi è giusto che x.next sia null.\\
Testando funziona anche se cancello l'unico elemento all'interno della lista.\\
Il tempo della cancellazione è costante, se non considero la ricerca, se considero la ricerca allora
il tempo della cancellazione dipenderà da essa dato che la search ha tempo $O(n)$.\\
Questa cancellazione chiaramente non va bene per le liste semplici, perchè non ho previous.\\
Dovrei modificare l'algoritmo per ripartire da head e tornare alla casella prima oppure tenermi due
puntatori che scorrono la lista e il secondo sta un passo indietro così quando trovo il valore
da cancellare il puntatore di appoggio ha la casella precedente.
\section{Esercizi}
\subsection{Data una lista in input invertirla}
Due possibilità:
\begin{itemize}
    \item Scambio prev/next
    \item Dal fondo all'inizio copio in altra lista
\end{itemize} 
Il primo caso è un po' complesso perchè manipolare così tanti puntatori
potrebbe generare dei problemi di celle che diventano irraggiungibili e
non funziona con le liste semplici.\\
Mentre la seconda possibilità è più semplice.
\begin{lstlisting}[language=Java]
    Ribalta(L)
        p=head[L]
        head[L2] = p
        while p != null
            ListInsert(L2, p)
            p = p.next
        Return(head[L2])
\end{lstlisting}
Se viene richiesto all'esame scrivo l'algoritmo e scrivo
il codice di ListInsert.\\
\subsection{Ricerca palindroma in una lista doppia}
\begin{lstlisting}[language=Java]
    boolean Palindroma(L1)
        P1=head[L1]
        P2=tail[L1]
        while P1.key == P2.key AND P1 != P2 AND P2.next != P1
            P1=P1.next
            P2=P2.prev
        if P1==P2 OR P2.next == P1
            return(TRUE)
        else
            return(FALSE)
\end{lstlisting}
All'esame potremo usare tail a meno che non sia esplicitamente
vietato dal testo, basta esplicitare che si suppone che la lista ci dia
oltre a head anche tail.
\paragraph*{Tempo}Dato che devo scorrere l'intera lista, metà da un puntatore
e metà dall'altra, quindi il tempo è $\Theta(n)$.
\section{Esercizi Lista ricorsivi}
\subsection{Conta quante volte è presente uno specifico elemento in una lista}
\begin{lstlisting}[language=Java]
    int Conta (P, k)
    if (P == null)
        return(0)
    else
        Tot1 = Conta(P.next, k)
        if (P.key == k)
            Tot = 1
        else
            Tot = 0
        return Tot+Tot1
\end{lstlisting}
Si potrebbe anche fare Divide et Impera? Sì, ma sarebbe meno efficiente perchè
comunque dovrei scansionare tutta la lista per capire la dimensione e poi fare
le divisioni, non è sempre così, ma in questo caso non conviene.
\subsection{Contare quante coppie di valori in posizione consecutiva sono presenti in una lista}
Esempio 3,3,3,4,4 sono 3 coppie (3,3,3 conta per 2 perchè sono 2 coppie).
\begin{lstlisting}[language=Java]
    int Conta (P)
        if P == null OR p.next == null
            return(0)
        else
            if P.key == (P.next).key
                r=1
            else
                r=0
            r2=conta(p.next)
            return(r+r2)
\end{lstlisting}
Il caso base aggiuntivo serve perchè chiaramente se ho una lista di 1 elemento
non ci saranno coppie, o comunque se sono arrivato ad avere un elemento non posso
scansionare quello dopo perchè non esiste.
\subsection{Ordinare una lista}
Quali algoritmi posso implementare?
\begin{itemize}
    \item Selection Sort - Sì
    \item Insertio Sort - Sì
    \item Merge Sort - Sì, ma è inefficiente perchè la divisione richiede molto tempo
    \item Quick Sort - Sì ed è efficiente, perchè creare due indici che scorrono uno verso destra
    e uno verso sinistra e scegliere il Pivot è semplice
\end{itemize}
\section{Stack - Pile}
Uno Stack (tradotto Pila) è una struttura di tipo LIFO (Last In First Out), quindi
l'ultimo elemento inserito sarà il primo a uscire. La uso quando mi è comodo gestire 
una struttura dati in maniera LIFO, per esempio la gestione delle chiamate ricorsive dove solo quando
ho una return del caso base inizio a svuotare lo stack, oppure quando il compilatore sta analizzando i begin e
end, mano a mano che trovo begin metto una B sullo stack, quando trovo un end, tolgo la B dallo stack, fino
ad avere tutto lo stack vuoto, se non è vuoto significa che il codice è scritto male, per esempio c'è un
begin senza end, oppure se lo stack è vuoto e lo voglio svuotare ancora vuol dire che ci sono troppi end.
\subsection{Operazioni}
\begin{itemize}
    \item Push(S,k) - Chiedo di inserire un elemento k nello stack S
    \item Pop(S) - Chiedo di togliere un elemento da S, non devo specificare quale perchè è per forza l'ultimo!
    \item Stackempty(S) (o isempty o emptysack) restituisce True se lo stack è vuoto e False altrimenti
    \item Top(S) - Restituisce il valore in cima allo stack senza toglierlo dallo stack (posso realizzarla facendo
    una Pop e poi una Push dello stesso elemento tolto)
\end{itemize}
Prima di fare la Pop è buona norma verificare se lo stack è vuoto, altrimenti non posso fare la Pop.\\
Corrispondenza con operazioni base delle strutture dati:
\begin{itemize}
    \item Push $\rightarrow$ Insert
    \item Pop $\rightarrow$ Delete
    \item Search - In questo caso devo svuotare mano a mano lo stack e cercare l'elemento e poi reinserire tutto
    \item Min/Max - Devo svuotare tutto e mano a mano verificare elemento per elemento se è il minore
\end{itemize}
Chiaramente Search e Min/Max sono forzature, gli Stack non sono adatti per questo tipo di operazioni.\\
\section{Realizzazione Stack}
Posso farlo in maniera statica (Array) o dinamica (Liste).
%L16-1 54:01%
