\chapter{Dal progetto al codice}
Gli elaborati creati fin'ora saranno utilizzati come input per il processo
di generazione del codice. Anche se la creazione di codice non fa parte
dell'OOA/D (Object Oriented Analysis/Design), è comunque l'obiettivo finale
della progettazione di un software. Durante la programmazione ci si devono
aspettare e si devono pianificare numerosi cambiamenti e deviazioni rispetto al
progetto e questo ha diverse implicazioni (per esempio aggiornare documentazione).
\section{Creazione di Classi e Interfacce}
I diagrammi di classe servono proprio a questo, dato che contengono
\begin{itemize}
    \item Nomi delle classi, interfacce e superclassi
    \item attributi
    \item firme delle operazioni
    \item associazioni tra classi
\end{itemize} 
Queste informazioni sono sufficienti per creare un'implementazione di base delle
classi, alcuni strumenti effettuano automaticamente queste operazioni (come RSA).
\subsection{Gestione delle Eccezioni}
Il comportamento del sistema quando sono generate delle eccezioni può essere descritto
con i modelli dinamici, se la gestione delle eccezioni non è opportunamente progettata il
loro effetto diventa preso un fenomeno globale e incontrollato.\\
\paragraph*{Alcune linee guida}
\begin{itemize}
    \item Definire un numero finito di eccezioni che possono essere rilasciate da 
    un componente e che siano interpretabili dal client (re-mapping delle eccezioni)
    \item Nascondere infomrazioni inutili ai client e diminuire il set di eccezioni (es.
    ThreadInterruptedException è scarsamente utile al client)
    \item Attenzione a non nascondere informazioni utili
    \item Le eccezioni sono appropriate quando si hanno fallimenti di risorse (disco, memoria, accesso rete)
    \item Il valore dell'eccezioni può essere utilizzare per fornire info aggiuntive
    \item In UML le eccezioni possono essere indicate nelle stringhe di proprietà dei messaggi
    e delle dichiarazioni delle operazioni
\end{itemize}
\subsection{Ordine di implementazione delle classi}
Esistono 3 stili principali, di cui l'ultimo è un mix dei primi due:
\begin{enumerate}
    \item Guidato dagli scenari descritti nei modelli dinamici (si implementano più parti di diverse
    classi)
    \item Basato sulle classi - Ordine definito in base alle dipendenze
    \item Misto - Si implementano prima le classi che rappresentano le entità
    principali del sistema e si implementano iterativamente le operazioni di sistema
\end{enumerate}
\section{Progettare la visibilità}
La visibilità viene definita come la capacità di un oggetto di "vedere" o di avere un
riferimento ad un altro oggetto. Affinchè un oggetto mittente invii un messaggio a un oggetto
destinatario, il destinatario deve essere visibile al mittente - il mittente
deve avere qualche tipo di riferimento (o puntatore) all'oggetto destinatario.\\
Risulta fondamentale garantire le visibilità necessarie per consentire le interazioni fra gli oggetti.
\subsection{Visibilità tra oggetti}
Come possiamo determinare se una risorsa (ad esempio un'istanza) rientra nella portata
di un'altra?\\
La visibilità può essere ottenuta dall'oggetto A all'oggetto B in quattro modi comuni:
\begin{itemize}
    \item Visibilità per attributo - B è un attributo di A
    \item Visibilità per parametro - B è un parametro di un metodo di A
    \item Visibilità locale - B è un oggetto locale (non parametro) di A
    \item Visibilità globale - B è in qualche modo visibile globalmente
\end{itemize}
\subsection{Visibilità per attributo}
La visibilità per attributo da A a B esiste quando B è un attributo di A.\\
Si tratta di una visibilità relativamente permanente perchè persiste finchè A e B esistono,
è molto diffusa nei sistemi OO.
\subsection{Visibilità per parametro}
La visibilità per parametro da A e B esiste quando B viene passato come parametro ad un
metodo di A. Si tratta di una visibilità relativamente temporanea perchè persiste solo
nell'ambito del metodo.
\subsection{Visibilità locale}
La visibilità dichiarata localmente da A a B esiste quando B è dichiarato come oggetto locale
nell'interno di un metodo di A. Si tratta di una visibilità relativamente temporanea
perchè persiste solo nell'ambito del metodo.
\begin{itemize}
    \item Creare una nuova istanza locale e assegnarla ad una variabile locale
    \item Assegnare l'oggetto di ritorno da un'invocazione di metodo ad una variabile locale
\end{itemize}
\paragraph*{Trasformare la visibilità} è possible trasformare la visibilità locale
in visibilità per parametro oppure la visibilità per parametro in visibilità per attributo.
\subsection{Visibilità globale}
La visibilità globaile da A a B esiste quando B è globale per A. Si tratta di una
visibilità relativamente permanente perchè persiste finchè A e B esistono. la forma 
meno comune, puiò favorire alto accoppiamento. Un modo per ottenere questo risultato è quello
di assegnare un'istanza a una variabile globale (possibile in C++, ma non in Java).\\
Il metodo migliore per ottenere la visibilità globale è quello di utilizzare il pattern
Singleton.
\section{Test Driven Development}
Il TDD (Test Driven Development) è una delle pratiche introdotte da Extreme Programming (XP) 
ed è diventata una pratica molto diffusa anche in metodologie non agili. Applicabile
anche a UP e Scrum, consente lo sviluppo iterativo ed evolutivo. Prevede Refactoring continuo
del codice.
\subsection{Benefici del TDD}
Alla fine dell'attività di sviluppo è stata ottenuta sia l'implementazione della classe che i suoi
casi di test d'unità/integrazione e quindi ci siamo tolti un bel po' di lavoro, dato che
altrimenti andrebbe fatto tutto dopo lo sviluppo delle classe.\\
Interfaccia e comportamenti saranno dettagliati dato che si dovrà ragionare sui
metodi necessari ai test e sui possibili comportamenti. Il testing è oltretutto ripetibile
automaticamente. Ci sarà anche maggior confidenza nel cambiare il sistema e il codice sarà
migliore.
\paragraph*{Tipologie di test}
\begin{itemize}
    \item Test di unità
    \item Test di integrazione
    \item Test di sistema
    \item Test di accettazione
    \item Test di regressione
\end{itemize}
\subsection{Test di unità}
Il test di unità si traduce in:
\begin{itemize}
    \item Scrivere il codice di un test prima della classe da testare
    \item Implmenetare parte della classe in modo che questa superi il test
    \item Scrivere un nuovo caso di test
    \item Reiterare
\end{itemize}
Dopo aver scritto i casi di test procediamo con l'implementazione.
Una volta che i casi di test sono stati superati dall'implementazione attuale procediamo
progettando nuovi casi di test oppure passando ad una nuova classe/metodo.
\paragraph*{Schema dei metodi di test di unità}
\begin{itemize}
    \item Preparazione - Crea l'oggetto da verificare (detto anche fixture)
    \item Esecuzione - Far fare qualcosa alla fixture al fine di eseguire alcune operazioni
    che si desidera testare
    \item Verifica - Verifica che i risultati ottenuti corrispondono a quelli previsti
    \item Rilascio - Opzionalmente rilascia o ripulisce gli oggetti e le risorse utilizzate nel test
\end{itemize}
\paragraph*{Esempi di Framework di test}
xUnit è un Framework per test di unità per molti linguaggi, per esempio NUnit è per .NET,
mentre JUnit è per Java.\\
\subsection{Ciclo del TDD}
\begin{itemize}
    \item Scrivere un caso di test che fallisce 
    \begin{itemize}
        \item Non scrivere codice di produzione fino a quando non hai scritto un
        test unitario
        \item Non scrivere più di un test di quanto è sufficiente per far fallire la
        compilazione o esecuzione del test
    \end{itemize}
    \item Scrivi il codice più semplice possibile per far passare il test
    \item Riscrivi o ristruttura il codice migliorandolo, oppure passa a scrivere il
    prossimo test unitario
\end{itemize}
Il Refactoring può essere applicato dopo aver effettuato ciascun test, oppure dopo diversi
test.
\chapter{Refactoring}
\section{Varie definizioni}
Il refactoring è il processo di modifica di un sistema software che non altera il suo
comportamento esterno e migliora la sua struttura interna (più semplice da capire e modificare).\\
Un'altra definizione è che il refactoring è un cambiamneto al sistema che lascia inalterato
il suo comportamento, ma che migliora alcune qualità funzionali come semplicità, flessibilità,
chiarezza, performance, riusabilità, manutenibilità.\\
\subsection{Quando fare refactoring}
\begin{itemize}
    \item Quando aggiugi una funzione
    \item Quando hai bisogno di fixare un bug
    \item Mentre fai revisione del codice
    \item Quando il codice è difficile da capire
\end{itemize}
\subsection{Quando NON fare refactoring}
\begin{itemize}
    \item Quando il codice non funzione
    \item Quando sei troppo vicino a una deadline
    \item QUando il design è così pessimo che è necessario riscrivere il codice
    \item Prima di effettuare il refactoring, assicurati di avere un buon set di casi di test
\end{itemize}
\subsection{Come effettuare refactoring}
\begin{itemize}
    \item Essere sicuro che i testi passini
    \item Trova del codice che "smells" (puzza)
    \item Determina come semplificare il codice
    \item Effettuare le semplificazioni
    \item Esegui Test per verificare che non siano stati introdotti bug
    \item Ripeti il processo finchè la "smell" (puzza) non se nè andata
\end{itemize}
\subsection{Perchè fare refactoring}
\begin{itemize}
    \item Migliorare il design del test (che decade nel tempo)
    \item Ridurre la quantità di codice richiesta per completare un task (rimuovendo
    codice inutile)
    \item Migliorare la leggibilità del codice
    \item Ti aiuta a trovare Bug (codice più complesso è più soggetto ad avere bug)
\end{itemize}
\subsection{Problemi con il refactoring}
\begin{itemize}
    \item Database (richiede di modificare i dati per adattarsi al nuovo design,
    la migrazione più essere molto lungha e costosa)
    \item Personal Ownership of Code
    \item Cambiare le interfacce (interfacce pubbliche non possono essere cambiate)
\end{itemize}
\subsection{Esempi di refactoring}
\begin{itemize}
    \item Extract Method - Trasforma un metodo lungo in uno più breve, estraendone una parte in
    un metodo di supporto
    \item Extract Class - Crea una nuova classe e vi muove alcuni campi e metodi di un'altra classe
    \item Move Method - Crea un nuovo metodo, con un corpo simile, nella classe che lo
    usa di più
\end{itemize}
\section{Code Smells}
La nozione di code smells è molto importante per il refactoring.\\
Si tratta sostanzialmente di caratteristiche che sono forti indicatori di una struttura
cattiva che dovrebbe essere ristrutturata.\\
\begin{quote}
    If it stinks, change it. (M.Fowler, Refactoring)
\end{quote}
I code smelss sono regole empiriche che indicano che il codice potrebbe essere migliorato.
Risulta sempre importante valutare il caso specifico, perchè non sempre un code smell porta
necessariamente a un refactoring. Comunque un codice che presenta code smells è probabile
che significhi che dovresti cambiare qualcosa.\\
\section{Bad Smells in Code}
\begin{itemize}
    \item Duplicated Code
    \item Long Method
    \item Large Class
    \item Long Parameter List
    \item Divergent Change
    \item Shotgun Surgery
    \item Feature Envy
    \item Data Clumps
    \item Primitive Obsession
    \item Switch Statements
    \item Parallel Inheritance Hierarchies
    \item Lazy Class
    \item Speculative Generality
    \item Temporary Field
    \item Message Chain
    \item Middle Man
    \item Inappropriate Intimacy
    \item Alternative Classes with Different Interfaces
    \item Incomplete Library Class
    \item Data Class
    \item Refused Bequest
    \item Comments
\end{itemize}
Uno smells è un sintonmo, il refactoring è la cura. Usa il relativo refactoring per
il relativo smells. Anche se stessi sintomi possono necessitare di cure diverse, così come
ogni smelss può suggerire più di un refactoring.
\subsection{Duplicated Code}
Due frammenti di codice che sembrano uguali.\\
I duplicati si verificano solitamente quando più programmatori stanno lavorando
su differenti parti di uno stesso programma simultaneamente e dato che stanno 
lavorando su differenti task, potrebbero non accorgersi che stanno creando codice che
è già stato creato da altri colleghi.\\
Si tratta di duplicazione anche quando specifiche parti di codice sembrano diverse,
ma fanno la stessa cosa. Questo tipi di codice duplicato è difficile da trovare e sistemare.\\


