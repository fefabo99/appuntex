\chapter{Progettazione orientata agli oggetti}
Fino ad ora attraverso l'analisi dei requisiti e l'analisi a oggetti ci siamo
interessati all'imparare a fare la cosa giusta, mentre il lavoro successivo
è fare la cosa bene, attraverso \textbf{la progettazione}.
\\ Ricordiamoci sempre che non dobbiamo prevedere tutto all'inizio (anche perchè
spesso è impossibile), ma dobbiamo necessariamente provocare il cambiamento
all'inizio del progetto per poter scoprire e modificare alcuni requisiti di progettazione
e implementazione. I \textbf{metodi iterativi ed evolutivi} esistono per questo,
abbracciano il cambiamento. Si cerca però di provocare i cambiamenti maggiori nelle
fasi iniziali per avere obiettivi più stabili per le iterazioni successive.
\chapter{Architettura Logica}
Siamo passati da un lavoro di analisi ad un lavoro di progettazione, si inizia
quindi a pensare su larga scala. La progettazione di un tipico sistema
orientato agli oggetti è basata su diversi \textbf{strati architetturali},
come per esempio uno strato per l'interfaccia utente, uno per la logica applicativa, ecc.
\section{Che cos'è l'architettura logica}
L'\textbf{architettura logica} di un sistema software è l'organizzazione su larga scala
delle classi software in package (o namespace), sottoinsiemi e strati.
\\ Uno stile comune per la l'architettura logica è l'\textbf{l'architettura a strati}.
\subsection{Architettura a strati}
Uno strato è un gruppo a grana molto grossa di classi, package o sottosistemi, che ha
delle responsabilità coese rispetto a un aspetto importante del sistema.
\\ Gli strati sono organizzati in modo gerarchico, quelli più alti ricorrono a 
servizi degli strati più bassi (normalmente non avviene il contrario).
\\ Gli strati normalmente comprendono
\begin{itemize}
    \item Presentazione - interfaccia utente
    \item Logica applicativa o strato del dominio - elementi che rappresentano concetti
    del dominio
    \item Servizi tecnici
\end{itemize}
\paragraph*{Due tipi di architettura a strati}
\begin{itemize}
    \item Stretta - uno strato può richiamare solo i servizi dello strato
    immediatamente sottostante
    \item Rilassata - uno strato può richiamare i servizi di strati più bassi di diversi
    livelli
\end{itemize}
Noi ci concentreremo sullo \textbf{strato della logica applicativa (o strato del dominio)}.
\section{Che cos'è un'architettura software}
\begin{itemize}
    \item L'insieme delle decisioni significative sull'organizzazione di un sistema
    software
    \item La scelta degli elementi strutturali da cui è composto il sistema e delle
    relative interfacce
    \item La specifica della collaborazione tra gli elementi strutturali
    \item La composizione di questi elementi strutturali e comportamentali in sottosistemi via
    via più ampi
    \item Lo stile architetturale che guida questa implementazione
\end{itemize}
L'architettura software ha a che fare con la larga scala.
\section{Diagrammi dei Package}
L'architettura logica può essere illustrata mediante un diagramma dei package
di UML, dove uno strato può essere modellato come un package UML.
Un package UML può ragguppare qualunque cosa (classi, altri package, casi d'uso).
\begin{itemize}
    \item \'E molto comune l'annidamento di package
    \item Per mostrare la dipendenza tra i package viene utilizzata una dipendenza UML
    \item Un package UML rappresenta un namespace, in questo modo è possibile
    definire due classi con lo stesso nome su package diversi
\end{itemize}
\subsection{Progettzione degli strati}
Organizzare l astruttura logica di un sistema in strati separati con responsabilità
distine e correlate, con una separazione netta e coesa degli interessi:
Come detto in precedenza:
\begin{itemize}
    \item Gli strati inferiori sono servizi generali e di basso livello
    \item Gli strati superiori sono più specifici per l'applicazione
\end{itemize}
Collaborazione e accoppiamenti vanno dagli strati più alti a quelli più bassi.
L'obiettivo è suddividere un sistema in un insieme di elementi software che
per quanto possibile, possano essere sviluppati e modificati ciascuno
\textbf{indipendentemente dagli altri}.
Nella slide 16 viene riportato un esempio di scelta comune per gli strati,
qui di seguito il link per la slide: \href{https://elearning.unimib.it/pluginfile.php/1463482/mod_resource/content/2/08_Dai%20requisiti%20alla%20progettazione%20e%20architettura%20logica.pdf}{Link slide} 
\subsection*{Vantaggi dell'uso a strati}
La sperazione provocata dall'utilizzo degli strati crea diversi vantaggi fra cui:
\begin{itemize}
    \item riduce l'accoppiamento e le dipendenze, migliora la coesione, aumenta la possibilità di riuso e aumenta
    la chiarezza.
    \item La complessità relativa a questi aspetti è incapsulata e può essere
    decomposta
    \item alcuni strati possono essere sostituiti da nuove implementazioni
    \item Gli strati più bassi contengono funzioni riusabili
    \item Alcuni strati possono essere distribuiti
    \item Lo sviluppo del team è favorito dalla segmentazione logica     
\end{itemize}
\subsection*{Responsabilità coese e seperazione degli interessi}
In uno strato le responsabilità degli oggetti devono essere fortemente coese
l'uno all'altro e non devono essere mescolate con le responsabilità degli altri
strati.
\section{Oggetti e logica applicativa}
Un oggetto software è un oggetto con nomi e informazioni simili al dominio
del mondo reale e assegnare ad esso responsabilità della logica applicativa, un oggetto
di questo tipo è chiamato un oggetto di dominio.
\\ Rappresenta una cosa nello spazio del dominio del problema e ha una logica applicativa
o di business correalata.
\\ Progettando gli oggetti in questo modo si arriva a uno strato della logica
applicativa che può essere chiamato \textbf{strato del dominio} dell'architettura
\subsection{Definizione livelli, trati e partizioni}
\begin{itemize}
    \item Livello (tier): solitamente indica un nodo fisica di elaborazione 
    \item Strato (layer): una sezione verticale dell'architettura
    \item Partizione (partition): una divisione orizzontale di sottosistema di uno strato
\end{itemize}
\subsection{Principio di separazione Modello-Vista}
Gli oggetti di dominio (modello) non devono essere connessi o accoppiati direttamente agli
oggetti UI (vista).
\\ Un rilassamento legittimo di questo principio è il \textbf{Pattern Observer},
qua gli oggetti del dominio inviano messaggi a oggetti della UI, visti però solo
indirettamente, in termini di un'interfaccia come PropertyListener.
L'oggetto di dominio non sa che quell'oggetto della UI è un oggetto UI, non
conosce la sua classe UI concreta, sa solo che l'oggetto implementa l'interfaccia
(non UI) PropertyListener.
\section{Legame tra SSD, operazioni di sistema e strati}
I messaggi inviati dallo strato UI allo strato del dominio sono i messaggi mostrati
negli SSD.
\section{Verso la progettazione a oggetti}
Gli sviluppatori hanno 3 modalità per progettare gli oggetti:
\begin{itemize}
    \item Codifica - La progettazione avviene durante la codifica
    \item Disegno, poi codifica - Disegnare alcuni diagrammi UML e poi passare al punto 1
    \item Solo disegno - Lo strumento genererà il codice a partire dai diagrammi
\end{itemize}
Noi tratteremo il disegno leggero di UML
\subsection*{Agile Modeling e il disegno leggero di UML}
Gli obiettivi sono ridurre il costo aggiuntivo del disegno e modellare per comprendere
e comunicare, anzichè documentare. La modellazione agile comprende anche le seguenti
pratiche:
\begin{itemize}
    \item Modellare insieme agli altri
    \item Creare diversi modelli in parallelo
\end{itemize}
Ci sono due tipi di modelli per gli oggetti:
\begin{itemize}
    \item Statici
    \item Dinamici
\end{itemize}
Creare questi modelli in parallelo
\paragraph*{Modelli dinamici}
\begin{itemize}
    \item Diagrammi di sequenza e comunicazione
    \item I più importanti e difficili da creare
    \item Si applicano \begin{itemize}
        \item La progettazione guidata delle responsabilità
        \item I principi di GRASP
    \end{itemize}
\end{itemize}
\paragraph*{Modelli statici}
\begin{itemize}
    \item Diagrammi delle classi
    \item Utili come sintesi e come base per la struttura del codice
\end{itemize}

\chapter{Diagrammi di interazione}
\section{Che sono sono gli oggetti}
Un oggetto è un pacchetto coeso di dati e funzioni incapsulate in una unità
riusabile. La parte dei dati è composta da attributi, mentre il comportamento
è definito dalle operazioni.
Tutti gli oggetti hanno:
\begin{itemize}
    \item Identità: ogni oggetto ha il suo identificativo univoco
    \item Stato: viene stabilito dai valori effettivi dei dati memorizzati in un oggetto
    ad un certo istante
    \item Comportamento: l'insieme delle operazioni che l'oggetto può eseguire
\end{itemize}
I dati sono nascosti all'interno dell'oggetto (insapsulamento) e sono accessibili
solo attraverso le operazioni, questo favorisce software più robusto e codice riusabile.
Gli oggetti collaborano tra loro attraverso messaggi, essi causano l'invocazione
delle operazioni da parte dell'oggetto.
\\ In UML i \textbf{diagrammi di interazione} illustrano il modo in cui gli oggetti
interagiscono attraverso lo scambio di messaggi. Sono utilizzati per la
\textbf{modellazoone dinamica degli oggetti}.
\section{Interazioni}
Un'interazione è una specifica di come alcuni oggetti si scambiano messaggi nel tempo
 per eseguire un compito nell'ambito di un certo contesto.
I diagrammi di interazione catturano un'interazione come:
\begin{itemize}
    \item Linee di vita - partecipanti nell'interazione
    \item Messaggi - Comunicazioni tra linee di vita
\end{itemize}
\subsection{Linee di vita}
Una linea di vita rappresenta un singolo partecipante a un'interazione:
raffigura come un'istanza del classificatore partecipa all'interazione.
Le linee vita hanno:
\begin{itemize}
    \item Nome: usato per far riferimento alla linea vita nell'interazione
    \item Tipo: nome del classificatore di cui rappresenta un'istanza
    \item Selettore: una condizione booleana che seleziona una specifica istanza
\end{itemize}
\subsection{Messaggi}
Un messaggio rappresenta la comunicazione tra due linee vita e può essere di diverse
tipologie:
\begin{itemize}
    \item Sincrono
    \item Asincrono
    \item Di ritono
    \item Creazione dell'oggetto
    \item Distruzione dell'oggetto
    \item Messaggio trovato
    \item Messaggio perso
\end{itemize}
\section{Diagrammi di interazione}
\begin{itemize}
    \item Diagrammi di sequenza
    \item Diagrammi di comunicazione
    \item Diagrammi di interazione generale
    \item Diagrammi di temporizzazione
\end{itemize}
\subsection{Diagrammi di sequenza}
\begin{itemize}
    \item Mostra l'interazione tra un insieme di oggetti.
    \item Enfatizza la sequenza temporale degli scambi di messaggi
    \item Mostra interazioni ordinate in una sequenza temporale
    \item Non mostra le relazioni degli oggetti (possono essere dedotte dagli invii di messaggi)
\end{itemize}
Formato a steccato.
\subsection{Diagramma di comunicazione}
Un diagramma che mostra l'interazione tra un insieme di oggetti (formato a grafo o rete).
Mostra gli aspetti strutturali di un'interazione - mostrando come si collegano le linee
di vita. Il collegamento indica l'esistenza di qualche forma di navigabilità tra gli oggetti.
Nella side 51 troviamo il dettaglio di come scorrono i messaggi e di come numerare una sequenza.
\paragraph*{Messaggi condizionali} Anche in questo caso è possibile avere delle condizioni di diverso
tipo, possono essere per esempio mutuamente esclusive o iterazioni.
\begin{itemize}
    \item Enfatizza le relazioni strutturali tra gli oggetti
    \item Sono utilizzati per esplicitare le relazioni degli oggetti
\end{itemize}
\'E consigliato creare i digrammai delle classi e di interazione in parallelo per
dare risalto non solo agli aspetti statici (diagramma delle classi), ma anche a quelli
dinamici (diagrammi di interazone).
\paragraph*{Auto-delegazione} è quando una line vita invia un messaggio a se stessa,
generando un'attivazione annidata.
\paragraph*{Distruzione} Per indicare la distruzione di un oggetto si termina la
linea vita con una grossa croce.
\subsection*{Frammenti combinati (Frame)}
I diagrammi di sequenza possono essere divisi in aree chiamate frammenti combinati.
I frammenti combinati hanno uno o più operandi, l'operatore determina come verranno
eseguiti gli operandi. Le condizioni di guardia stabiliscono se i loro operandi devono
essere esegiti. L'esecuzione avveniene solo se la condizioni di guardia è valutata
vera.
\paragraph*{Operatori più usati}
\begin{itemize}
    \item opt - Option - Il suo unico operando viene eseguito se e solo se la condizione è vera
    \item alt - Alternatives - Messaggi condizionali mutuamente esclusivi (2 o più) operandi (aka if else)
    \item loop - loop
    \item break - break
    \item ref - Reference
\end{itemize}
\subsection*{Iterazioni con loop e break}
Sintass del loop:
\begin{itemize}
    \item Ciclo senza max o min equivale a una condizione di ciclo infinito
    \item Se viene specificato solo min allora si considera max=min
    \item La condizione può essere booleana o un testo (purchè il significato sia chiaro)
\end{itemize}
Il break indica in quale condizione il loop viene interrotto e che cosa succede in seguito,
il resto del ciclo non viene eseguito dopo il break.
Nelle slide vengono riportati diversi esempi di iterazioni (da slide 33 in poi) \href{https://elearning.unimib.it/pluginfile.php/1463483/mod_resource/content/2/10_Diagrammi%20di%20interazione.pdf}{Link Slide}
\paragraph*{Reference} Fondamentali per correlare i diagrammi fra di loro (slide 44).
\section{Diagrammi di Interazione Generale}
Modellano il flusso di controllo tra interazioni ad alto livello, mostrano le interazioni
e le occorrenze di interazioni, hanno la sintassi dei diagrammi di attività.

\chapter{Diagramma delle classi}
\paragraph*{Cosa sono le classi} Una classe modella un insieme di oggetti omogenei
(le istanze della classe) ai quali sono associate proprietà statiche (attributi) e 
dinamiche (operazioni).
\\ La classificazione è uno dei più importanti modi che noi abbiamo per organizzare la
nostra vista del mondo.
\\ Per identificare un oggetto che è istanza di una classe si traccia un arco
\textit{instantiate}.
\\ Per descrivere una classe in notazione UML è consigliabile usare nomi
descrittivi ed evitare abbreviazioni.
\paragraph*{Classificatore} Un classificatore si definisce come elemento di modello
che descrive caratteristiche comportamentali e strutturali, sono una generalizzazione
di molti degli elementi di UML, come classi, interfacce, casi d'uso e attori.
Nei diagrammi delle classi i due classificatori più comuni sono le classi e le
interfacce.
\section{Proprietà Strutturali}
In UML le proprietà strutturali di un classificatore comprendono:
\begin{itemize}
    \item Gli attributi
    \item Le estremità di associazioni
\end{itemize}
\subsection{Attributi}
Un attributo modella una propeità locale della classe ed è caratterizzato da un nome
e dal tipo dei valori associati. Ogni attributo stabilisce una proprietà locale valida per
tutte le istanze (per locale si intende che è indipendente dagli altri oggetti).
\paragraph*{UML} In UML negli attributi si indica obbligatoriamente un nome, opzionalmente
si può indicare la visibilità (di default si ipotizza che siano privati).
\paragraph*{Identificatore di oggetti} Due oggetti con identificatori distinti sono
comunque distinti, anche se hanno i valori di tutti gli attributi uguali.
\paragraph*{Visibilità} Sono i 4 classici tipi già studiati in programmazione:
\begin{itemize}
    \item Pubblica
    \item Privata
    \item Protetta - Solo operazioni appartenenti alla classe o ai suoi discendenti possono
    accedere ai membri con visibilità protetta
    \item Package - Ogni elemento nello stesso package della classe può accedere ai membri
    della classe con visibilità package
\end{itemize}
\paragraph*{Molteplicità} Consideriamo un attributo B di tipo T di una classe C.
Se la molteplicità non viene indicata si intende 1:1, altrimenti si indica per
esempio x..y per dire che B associa ad ogni istanza di C al minimo x e al massimo y valori
di tipo T. Nelle istanza il multivalore si indica mediante un insieme (tipo array).
\subsection{Associazioni in UML}
Per il momento, ci limitamo a discutere associazioni tra due classi (ma le associazioni
possono coinvolgere N classi).
\\ Un'associazione tra una classe C1 e una classe C2 modella una relazione matematica
tra l'insieme delle istanze di C1 e l'insieme delle istanze di C2.
Gli attributi modellano proprietà locali di una classe, le associazioni modellano
proprietà che coinvolgono altre classi.
\paragraph*{Collegamenti} Le istanze delle associazioni si chiamano collegamenti.
Come gli oggetti sono istanze delle classi, così i collegamenti sono istanze delle associazioni.
Al contrario degli oggetti però i collegamenti non hanno identificatori espliciti:
un collegamento è implicitamente identificato dalla coppia (o in generale dalla
ennupla) di oggetti che esso rappresenta. Ciò non toglie che tra due classi possono essere definite
più associazioni.
\paragraph*{Sintassi} Le associazioni possono essere indicate o con il nome
dell'associazione o con il nome dei ruoli (es. Azienda - Persona : Datore - Dipendente) e la
relativa cardinalità. A differenza della cardinalità però il ruolo non aggiunge nulla
al significato pratico dell'associazione. 
A volte è utile specificare un verso, ma questo non significa
che l'associazione ha un verso, è solo relativo al verso che il nome dell'associazione
evoca, ma anche in questo caso non ha un significato in termini pratici.
L'unico caso in cui il ruolo è obbligatorio è nel caso di associazioni che insistono più
volte sulla stessa classe e rappresentano una relazione non simmetrica.
\paragraph*{Perchè usare i ruoli} Risolvono alcune ambiguità a livello schematico, rendendo
più chiaro cosa si intende rappresentare. In alcuni casi però i ruoli non sono
significativi, come nei casi di relazioni simmetriche (esempio Stato confina con).
\subsection*{Navigabilità}
La navigabilità indica che è possibile spostarsi da n qualsiasi oggetto della classe
origine a uno o più oggetti della classe destinazione. Gli oggetti della classe
di orgine possono fare riferimento a oggetti della classe di destinazione utilizzando
il nome del ruolo.
\subsection*{Molteplicità} La molteplicità limita il numero di oggetti di una classe
che possono partecipare in una relazione in un dato insieme. Se la molteplicità non viene
indicata esplicitamente allora è indefinita.
\subsection*{Attributi di associazioni} Analogamente alle classi, anche le associazioni
possono avere attributi. Formalmente, un attributo di una associazione è una funzione
che associa ad ogni collegamento che è istanza dell'associazione un valore di riferimento.
\paragraph*{Parallelo con Basi di Dati} Praticamente è un attributo di relazione, dato che
è un valore che ha senso di esistere solo se esiste la relazione (in questo caso collegamento).
\paragraph*{Classi associazioni nella progettazione} Nessuno dei linguaggi OO comunemente
utilizzati supporto le classi associazione, per questo vengono reificate tramite l'uso di
classi di progettazione, collegandole alle classi con l'aggregazione e la composizione
(da utilizzare opportunamente in base alla cardinalità decidendo chi sia il tutto e chi sia la parte).
Come in basi di dati, anche qua esistono le associazioni n-arie che modellano una
relazione matematica tra n insiemi.
\subsection*{Associazioni e Attributi}
Utilizzare le associazioni quando la classe di destinazione è una parte importante del modello.
\\ Utilizzare gli attributi quando:
\begin{itemize}
    \item La classe di destinazione non è una parte importante del modello (ad esempio un tipo primitivo come stringa)
    \item La classe di destinazione è solo un dettaglio di implementazione, ad esempio
    una componente di libreria
\end{itemize}
\subsection{Semantica della collezione : Stringhe di proprietà}
UML mette a disposizione delle proprietà standard che possono essere applicate alle
molteplicità per indicare la semantica richiesta dalla collezione:
\begin{itemize}
    \item ordered - gli elementi dell'insieme sono ordinati
    \item unordered - non c'è un ordine definito
    \item unique - gli elementi dell'insieme sono tutti univoci
    \item nounique - la collezione può contenere elementi duplicati
\end{itemize}
\'E consentito l'utilizzo di parole chiavi definite dall'utente (esempio List).
\subsection{Operazioni}
Un'operazione di UML è una dichiarazione, con un nome, dei parametri, un tipo di ritorno,
un elenco di eccezioni e magari un insieme di vincoli di precodizioni e post condizioni.
\paragraph*{title}*{Definizione di un'operazione}
I nomi delle operazioni sono solitamente in minuscolo (evitare simboli speciali).
UML consente che le firme delle operazioni siano scritte in un qualunque linguaggio, 
purchè sia notificato al lettore o allo strumento.
\paragraph*{Metodi}
In UML un metodo è l'implementazione di un'operazione.
\subsection*{Parole chiave}
Un decoratore testuale è una parola chiave utilizzata per classificare un elemento
di modello. Qui di seguito alcuni esempi:
\begin{itemize}
    \item actor - classifica un attore
    \item interface - un'interfaccia
    \item abstract - una classe astratta (che quindi non può essere istanziata)
    \item ordered - insieme di oggetti con un ordine predefinito
\end{itemize}
\section{Generalizzazione, Ereditarietà, Polimorfismo, Overriding}
\subsection*{Generalizzazione}
In UML la relazione is-a si modella mediante la nozione di generalizzazione 
(ancora una volta parallelo con basi di dati). La generalizzazione coinvolge una superclasse
ed una o più sottoclassi dette classi derivate, il significato è che ogni
istanza di ciascuna sottoclasse è anche istanza della superclasse. Quando la sottoclasse
è una, la generalizzazione modella appunto la relazione is-a tra sottoclase e la superclasse.
\\ In UML si usa una freccia dal basso verso l'alto.
\\ La superclasse può generalizzare più sottoclassi rispetto ad un unico criterio (Persona - Maschio/Femmina)
Oppure si possono creare più generalizzazioni diverse (secondo criteri diversi).
Una generalizzazione può essere disgiunta oppure no (Maschio e Femmina è disgiunta, mentre
per esempio Studente Lavoratore no). Onverlapping (non disgiunta) è default.
\paragraph*{Generalizzazione complete} Una generalizzazione può essere completa o no (Studente
Lavoratore è incompleta, Maschio Femmina è completa). Incompleta è default.
\subsection*{Ereditarietà}
Principio di Ereditarietà, ogni proprietà della superclasse è anche una proprietà
della sottoclasse e non si riporta esplicitamente nel diagramma.
\paragraph*{Ereditarietà Multipla} UML consente l'ereditarietà multipla
\subsection*{Overriding}
L'overriding è la possibilità di ridefinire un'operazione ereditata da una superclasse
La firma dell'operazione è data dal nome dell'oerazione, il tipo di ritono e tutti i parametri.
I nomi dei parametri non vengono considerati parte della firma.
\subsection*{Polimoorfismo}
Un'operazione poliformica ha molte implementazioni (forme).
Le sottoclassi avranno l'esigenza di ridefinire alcune funzioni ereditate per poterle
rendere specifiche per le lore necessità.
\section{Dipendenza}
In UML una dipendenza è una relazione di dipendenza.
Si utilizza quando un elemento cliente (classi, package, casi d'uso) è a conoscenza di
un elemento fornitore e un cambiamento nel fornitore potrebbe influire sul cliente (rompendone il funzionamento).
\\ Un elemento è \textbf{accoppiato} con un altro elemento o dipendenza da un altro elemento.
\section{Interfaccia}
Un'interfaccia è un insieme di funzionalità pubbliche identificate da un nome e separano
le specifiche di una funzionalità dall'implementazione, un'interfaccia definisce un contratto
e tutti i classificatori che la realizzano devono rispettare.
\paragraph*{Come individuare le interfacce}
Esaminando ogni associazione chiediamoci, dovrebbe questa associazione essere associata ad 
una classe particolare o dovrebbe essere più flessibile?
\\ Lo stesso per i messaggi. Lo scopo è raggruppare più operazione che potrebbero essere
riusabili altrove o attributi.
\subsection*{Interfacce per stabilire protocolli}
Le interfacce sono molto utili perchè tramite il loro utilizzo è possibile stabilire protocolli
comuni che potrebbero essere realizzati da molte classi e molti componenti.
\\ Le interfacce facilitano l'inserimento di nuove classi nel sistema. Permette
anche di nascondere dettagli implementativi di sottosistemi complessi.
\paragraph*{Architettura} L'insieme dei sottosistemi e delle interfacce di progetto
costituisce l'architettura di alto livello di un sistema. Per capire e mantenere questa
architettura, l'insieme dovrebbe essere organizzato in modo coerente, applicando un 
architettura a strati.
\subsection*{Vantaggi e Svantaggi interfacce}
\paragraph*{Vantaggi}
\begin{itemize}
    \item Quando progettiamo con le classi stiamo progettando specifiche implementazioni
    \item Quando progettiamo con interfacce stiamo invece progettando dei contratti che possono
    essere realizzati da molte implementazioni diverse (classi)
    \item La progettazione per interfacce svincola il modello da dipendenze dell'implementazione e 
    ne aumenta quindi la flessibilità e estendibilità
\end{itemize}
\paragraph*{Svantaggi}
\begin{itemize}
    \item Maggiore flessibilità significa anche più complessità. In teoria ogni operazione
    di ogni classe potrebbe essere un'interfaccia, ma in questo modo il sistema diventerebbe
    incomprensibile
    \item Maggior costo a livello di prestazioni
\end{itemize}
\section{Aggregazione e Composizione}
In UML un'aggregazione è un'associazione che rappresenta una relazione intero-parte
\\ Una composizione (aggregazione composta) è una forma forte di aggregazione in cui:
\begin{itemize}
    \item Una parte appartiene a un composto alla volta
    \item Ciascuna parte appartiene sempre a un composto
    \item Il composto è responsabile della creazione e cancellazione delle sue parti
\end{itemize}
