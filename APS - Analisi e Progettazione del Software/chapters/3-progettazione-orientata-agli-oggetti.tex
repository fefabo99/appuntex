\chapter{Progettazione orientata agli oggetti}
Fino ad ora attraverso l'analisi dei requisiti e l'analisi a oggetti ci siamo
interessati all'imparare a fare la cosa giusta, mentre il lavoro successivo
è fare la cosa bene, attraverso \textbf{la progettazione}.
\\ Ricordiamoci sempre che non dobbiamo prevedere tutto all'inizio (anche perchè
spesso è impossibile), ma dobbiamo necessariamente provocare il cambiamento
all'inizio del progetto per poter scoprire e modificare alcuni requisiti di progettazione
e implementazione. I \textbf{metodi iterativi ed evolutivi} esistono per questo,
abbracciano il cambiamento. Si cerca però di provocare i cambiamenti maggiori nelle
fasi iniziali per avere obiettivi più stabili per le iterazioni successive.
\chapter{Architettura Logica}
Siamo passati da un lavoro di analisi ad un lavoro di progettazione, si inizia
quindi a pensare su larga scala. La progettazione di un tipico sistema
orientato agli oggetti è basata su diversi \textbf{strati architetturali},
come per esempio uno strato per l'interfaccia utente, uno per la logica applicativa, ecc.
\section{Che cos'è l'architettura logica}
L'\textbf{architettura logica} di un sistema software è l'organizzazione su larga scala
delle classi software in package (o namespace), sottoinsiemi e strati.
\\ Uno stile comune per la l'architettura logica è l'\textbf{l'architettura a strati}.
\subsection{Architettura a strati}
Uno strato è un gruppo a grana molto grossa di classi, package o sottosistemi, che ha
delle responsabilità coese rispetto a un aspetto importante del sistema.
\\ Gli strati sono organizzati in modo gerarchico, quelli più alti ricorrono a 
servizi degli strati più bassi (normalmente non avviene il contrario).
\\ Gli strati normalmente comprendono
\begin{itemize}
    \item Presentazione - interfaccia utente
    \item Logica applicativa o strato del dominio - elementi che rappresentano concetti
    del dominio
    \item Servizi tecnici
\end{itemize}
\paragraph*{Due tipi di architettura a strati}
\begin{itemize}
    \item Stretta - uno strato può richiamare solo i servizi dello strato
    immediatamente sottostante
    \item Rilassata - uno strato può richiamare i servizi di strati più bassi di diversi
    livelli
\end{itemize}
Noi ci concentreremo sullo \textbf{strato della logica applicativa (o strato del dominio)}.
\section{Che cos'è un'architettura software}
\begin{itemize}
    \item L'insieme delle decisioni significative sull'organizzazione di un sistema
    software
    \item La scelta degli elementi strutturali da cui è composto il sistema e delle
    relative interfacce
    \item La specifica della collaborazione tra gli elementi strutturali
    \item La composizione di questi elementi strutturali e comportamentali in sottosistemi via
    via più ampi
    \item Lo stile architetturale che guida questa implementazione
\end{itemize}
L'architettura software ha a che fare con la larga scala.
\section{Diagrammi dei Package}
L'architettura logica può essere illustrata mediante un diagramma dei package
di UML, dove uno strato può essere modellato come un package UML.
Un package UML può ragguppare qualunque cosa (classi, altri package, casi d'uso).
\begin{itemize}
    \item \'E molto comune l'annidamento di package
    \item Per mostrare la dipendenza tra i package viene utilizzata una dipendenza UML
    \item Un package UML rappresenta un namespace, in questo modo è possibile
    definire due classi con lo stesso nome su package diversi
\end{itemize}
\subsection{Progettzione degli strati}
Organizzare l astruttura logica di un sistema in strati separati con responsabilità
distine e correlate, con una separazione netta e coesa degli interessi:
Come detto in precedenza:
\begin{itemize}
    \item Gli strati inferiori sono servizi generali e di basso livello
    \item Gli strati superiori sono più specifici per l'applicazione
\end{itemize}
Collaborazione e accoppiamenti vanno dagli strati più alti a quelli più bassi.
L'obiettivo è suddividere un sistema in un insieme di elementi software che
per quanto possibile, possano essere sviluppati e modificati ciascuno
\textbf{indipendentemente dagli altri}.
Nella slide 16 viene riportato un esempio di scelta comune per gli strati,
qui di seguito il link per la slide: \href{https://elearning.unimib.it/pluginfile.php/1463482/mod_resource/content/2/08_Dai%20requisiti%20alla%20progettazione%20e%20architettura%20logica.pdf}{Link slide} 
\subsection*{Vantaggi dell'uso a strati}
La sperazione provocata dall'utilizzo degli strati crea diversi vantaggi fra cui:
\begin{itemize}
    \item riduce l'accoppiamento e le dipendenze, migliora la coesione, aumenta la possibilità di riuso e aumenta
    la chiarezza.
    \item La complessità relativa a questi aspetti è incapsulata e può essere
    decomposta
    \item alcuni strati possono essere sostituiti da nuove implementazioni
    \item Gli strati più bassi contengono funzioni riusabili
    \item Alcuni strati possono essere distribuiti
    \item Lo sviluppo del team è favorito dalla segmentazione logica     
\end{itemize}
\subsection*{Responsabilità coese e seperazione degli interessi}
In uno strato le responsabilità degli oggetti devono essere fortemente coese
l'uno all'altro e non devono essere mescolate con le responsabilità degli altri
strati.
\section{Oggetti e logica applicativa}
Un oggetto software è un oggetto con nomi e informazioni simili al dominio
del mondo reale e assegnare ad esso responsabilità della logica applicativa, un oggetto
di questo tipo è chiamato un oggetto di dominio.
\\ Rappresenta una cosa nello spazio del dominio del problema e ha una logica applicativa
o di business correalata.
\\ Progettando gli oggetti in questo modo si arriva a uno strato della logica
applicativa che può essere chiamato \textbf{strato del dominio} dell'architettura
\subsection{Definizione livelli, trati e partizioni}
\begin{itemize}
    \item Livello (tier): solitamente indica un nodo fisica di elaborazione 
    \item Strato (layer): una sezione verticale dell'architettura
    \item Partizione (partition): una divisione orizzontale di sottosistema di uno strato
\end{itemize}
\subsection{Principio di separazione Modello-Vista}
Gli oggetti di dominio (modello) non devono essere connessi o accoppiati direttamente agli
oggetti UI (vista).
\\ Un rilassamento legittimo di questo principio è il \textbf{Pattern Observer},
qua gli oggetti del dominio inviano messaggi a oggetti della UI, visti però solo
indirettamente, in termini di un'interfaccia come PropertyListener.
L'oggetto di dominio non sa che quell'oggetto della UI è un oggetto UI, non
conosce la sua classe UI concreta, sa solo che l'oggetto implementa l'interfaccia
(non UI) PropertyListener.
\section{Legame tra SSD, operazioni di sistema e strati}
I messaggi inviati dallo strato UI allo strato del dominio sono i messaggi mostrati
negli SSD.
\section{Verso la progettazione a oggetti}
Gli sviluppatori hanno 3 modalità per progettare gli oggetti:
\begin{itemize}
    \item Codifica - La progettazione avviene durante la codifica
    \item Disegno, poi codifica - Disegnare alcuni diagrammi UML e poi passare al punto 1
    \item Solo disegno - Lo strumento genererà il codice a partire dai diagrammi
\end{itemize}
Noi tratteremo il disegno leggero di UML
\subsection*{Agile Modeling e il disegno leggero di UML}
Gli obiettivi sono ridurre il costo aggiuntivo del disegno e modellare per comprendere
e comunicare, anzichè documentare. La modellazione agile comprende anche le seguenti
pratiche:
\begin{itemize}
    \item Modellare insieme agli altri
    \item Creare diversi modelli in parallelo
\end{itemize}
Ci sono due tipi di modelli per gli oggetti:
\begin{itemize}
    \item Statici
    \item Dinamici
\end{itemize}
Creare questi modelli in parallelo
\paragraph*{Modelli dinamici}
\begin{itemize}
    \item Diagrammi di sequenza e comunicazione
    \item I più importanti e difficili da creare
    \item Si applicano \begin{itemize}
        \item La progettazione guidata delle responsabilità
        \item I principi di GRASP
    \end{itemize}
\end{itemize}
\paragraph*{Modelli statici}
\begin{itemize}
    \item Diagrammi delle classi
    \item Utili come sintesi e come base per la struttura del codice
\end{itemize}

\chapter{Diagrammi di interazione}
\section{Che sono sono gli oggetti}
Un oggetto è un pacchetto coeso di dati e funzioni incapsulate in una unità
riusabile. La parte dei dati è composta da attributi, mentre il comportamento
è definito dalle operazioni.
Tutti gli oggetti hanno:
\begin{itemize}
    \item Identità: ogni oggetto ha il suo identificativo univoco
    \item Stato: viene stabilito dai valori effettivi dei dati memorizzati in un oggetto
    ad un certo istante
    \item Comportamento: l'insieme delle operazioni che l'oggetto può eseguire
\end{itemize}
I dati sono nascosti all'interno dell'oggetto (insapsulamento) e sono accessibili
solo attraverso le operazioni, questo favorisce software più robusto e codice riusabile.
Gli oggetti collaborano tra loro attraverso messaggi, essi causano l'invocazione
delle operazioni da parte dell'oggetto.
\\ In UML i \textbf{diagrammi di interazione} illustrano il modo in cui gli oggetti
interagiscono attraverso lo scambio di messaggi. Sono utilizzati per la
\textbf{modellazoone dinamica degli oggetti}.
\section{Interazioni}
Un'interazione è una specifica di come alcuni oggetti si scambiano messaggi nel tempo
 per eseguire un compito nell'ambito di un certo contesto.
I diagrammi di interazione catturano un'interazione come:
\begin{itemize}
    \item Linee di vita - partecipanti nell'interazione
    \item Messaggi - Comunicazioni tra linee di vita
\end{itemize}
\subsection{Linee di vita}
Una linea di vita rappresenta un singolo partecipante a un'interazione:
raffigura come un'istanza del classificatore partecipa all'interazione.
Le linee vita hanno:
\begin{itemize}
    \item Nome: usato per far riferimento alla linea vita nell'interazione
    \item Tipo: nome del classificatore di cui rappresenta un'istanza
    \item Selettore: una condizione booleana che seleziona una specifica istanza
\end{itemize}
\subsection{Messaggi}
Un messaggio rappresenta la comunicazione tra due linee vita e può essere di diverse
tipologie:
\begin{itemize}
    \item Sincrono
    \item Asincrono
    \item Di ritono
    \item Creazione dell'oggetto
    \item Distruzione dell'oggetto
    \item Messaggio trovato
    \item Messaggio perso
\end{itemize}
\section{Diagrammi di interazione}
\begin{itemize}
    \item Diagrammi di sequenza
    \item Diagrammi di comunicazione
    \item Diagrammi di interazione generale
    \item Diagrammi di temporizzazione
\end{itemize}
\subsection{Diagrammi di sequenza}
\begin{itemize}
    \item Mostra l'interazione tra un insieme di oggetti.
    \item Enfatizza la sequenza temporale degli scambi di messaggi
    \item Mostra interazioni ordinate in una sequenza temporale
    \item Non mostra le relazioni degli oggetti (possono essere dedotte dagli invii di messaggi)
\end{itemize}
Formato a steccato.
\subsection{Diagramma di comunicazione}
Un diagramma che mostra l'interazione tra un insieme di oggetti (formato a grafo o rete).
Mostra gli aspetti strutturali di un'interazione - mostrando come si collegano le linee
di vita. Il collegamento indica l'esistenza di qualche forma di navigabilità tra gli oggetti.
Nella side 51 troviamo il dettaglio di come scorrono i messaggi e di come numerare una sequenza.
\paragraph*{Messaggi condizionali} Anche in questo caso è possibile avere delle condizioni di diverso
tipo, possono essere per esempio mutuamente esclusive o iterazioni.
\begin{itemize}
    \item Enfatizza le relazioni strutturali tra gli oggetti
    \item Sono utilizzati per esplicitare le relazioni degli oggetti
\end{itemize}
\'E consigliato creare i digrammai delle classi e di interazione in parallelo per
dare risalto non solo agli aspetti statici (diagramma delle classi), ma anche a quelli
dinamici (diagrammi di interazone).
\paragraph*{Auto-delegazione} è quando una line vita invia un messaggio a se stessa,
generando un'attivazione annidata.
\paragraph*{Distruzione} Per indicare la distruzione di un oggetto si termina la
linea vita con una grossa croce.
\subsection*{Frammenti combinati (Frame)}
I diagrammi di sequenza possono essere divisi in aree chiamate frammenti combinati.
I frammenti combinati hanno uno o più operandi, l'operatore determina come verranno
eseguiti gli operandi. Le condizioni di guardia stabiliscono se i loro operandi devono
essere esegiti. L'esecuzione avveniene solo se la condizioni di guardia è valutata
vera.
\paragraph*{Operatori più usati}
\begin{itemize}
    \item opt - Option - Il suo unico operando viene eseguito se e solo se la condizione è vera
    \item alt - Alternatives - Messaggi condizionali mutuamente esclusivi (2 o più) operandi (aka if else)
    \item loop - loop
    \item break - break
    \item ref - Reference
\end{itemize}
\subsection*{Iterazioni con loop e break}
Sintass del loop:
\begin{itemize}
    \item Ciclo senza max o min equivale a una condizione di ciclo infinito
    \item Se viene specificato solo min allora si considera max=min
    \item La condizione può essere booleana o un testo (purchè il significato sia chiaro)
\end{itemize}
Il break indica in quale condizione il loop viene interrotto e che cosa succede in seguito,
il resto del ciclo non viene eseguito dopo il break.
Nelle slide vengono riportati diversi esempi di iterazioni (da slide 33 in poi) \href{https://elearning.unimib.it/pluginfile.php/1463483/mod_resource/content/2/10_Diagrammi%20di%20interazione.pdf}{Link Slide}
\paragraph*{Reference} Fondamentali per correlare i diagrammi fra di loro (slide 44).
\section{Diagrammi di Interazione Generale}
Modellano il flusso di controllo tra interazioni ad alto livello, mostrano le interazioni
e le occorrenze di interazioni, hanno la sintassi dei diagrammi di attività.

\chapter{Diagramma delle classi}
\paragraph*{Cosa sono le classi} Una classe modella un insieme di oggetti omogenei
(le istanze della classe) ai quali sono associate proprietà statiche (attributi) e 
dinamiche (operazioni).
\\ La classificazione è uno dei più importanti modi che noi abbiamo per organizzare la
nostra vista del mondo.
\\ Per identificare un oggetto che è istanza di una classe si traccia un arco
\textit{instantiate}.
\\ Per descrivere una classe in notazione UML è consigliabile usare nomi
descrittivi ed evitare abbreviazioni.
\paragraph*{Classificatore} Un classificatore si definisce come elemento di modello
che descrive caratteristiche comportamentali e strutturali, sono una generalizzazione
di molti degli elementi di UML, come classi, interfacce, casi d'uso e attori.
Nei diagrammi delle classi i due classificatori più comuni sono le classi e le
interfacce.
\section{Proprietà Strutturali}
In UML le proprietà strutturali di un classificatore comprendono:
\begin{itemize}
    \item Gli attributi
    \item Le estremità di associazioni
\end{itemize}
\subsection{Attributi}
Un attributo modella una propeità locale della classe ed è caratterizzato da un nome
e dal tipo dei valori associati. Ogni attributo stabilisce una proprietà locale valida per
tutte le istanze (per locale si intende che è indipendente dagli altri oggetti).
\paragraph*{UML} In UML negli attributi si indica obbligatoriamente un nome, opzionalmente
si può indicare la visibilità (di default si ipotizza che siano privati).
\paragraph*{Identificatore di oggetti} Due oggetti con identificatori distinti sono
comunque distinti, anche se hanno i valori di tutti gli attributi uguali.
\paragraph*{Visibilità} Sono i 4 classici tipi già studiati in programmazione:
\begin{itemize}
    \item Pubblica
    \item Privata
    \item Protetta - Solo operazioni appartenenti alla classe o ai suoi discendenti possono
    accedere ai membri con visibilità protetta
    \item Package - Ogni elemento nello stesso package della classe può accedere ai membri
    della classe con visibilità package
\end{itemize}
\paragraph*{Molteplicità} Consideriamo un attributo B di tipo T di una classe C.
Se la molteplicità non viene indicata si intende 1:1, altrimenti si indica per
esempio x..y per dire che B associa ad ogni istanza di C al minimo x e al massimo y valori
di tipo T. Nelle istanza il multivalore si indica mediante un insieme (tipo array).
\subsection{Associazioni in UML}
Per il momento, ci limitamo a discutere associazioni tra due classi (ma le associazioni
possono coinvolgere N classi).
\\ Un'associazione tra una classe C1 e una classe C2 modella una relazione matematica
tra l'insieme delle istanze di C1 e l'insieme delle istanze di C2.
Gli attributi modellano proprietà locali di una classe, le associazioni modellano
proprietà che coinvolgono altre classi.

% Arrivato a Slide 30
