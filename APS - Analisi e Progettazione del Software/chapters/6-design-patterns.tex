\chapter{Design Patterns}
Un Design pattern è un modo di riutilizzare la conoscenza astratta di un problema e la
sua soluzione. Un pattern è una desrizione del problema e l'essenza della sua soluzione.
Dovrebbe essere sufficientemente astratto per essere riutilizzato in diversi contesti.
Le descrizioni dei pattern di solito fanno uso di caratteristiche orientate all'oggetto,
come l'eredità e il polimorfismo.\\
I design pattern sono emergi da alcuni anni come una delle tecniche più effiaci per
trasferire la conoscenza e l'esperienza dei progettisti, rendendola disponibile a tutti
in modo comprensibile e concreto.
\paragraph*{I DP aiutano a:}
\begin{itemize}
    \item Costruire del software che sia risuabile
    \item Evitare scelte che compromettano il riutilizzo del software
    \item Migliorare la documentazione e la manutenzione di sistemi esistenti
\end{itemize}
In pratica un design pattern è una regola che esprime una relazione tra un contesto,
un problema ed una soluzione.\\
Un design pattern nomina, astrae e identifica gli aspetti chiave di una struttura di
design comune, che la rendono utile per creare un design OO riusabile.\\
Identificano:
\begin{itemize}
    \item Le classi e le istanze che vi partecipano
    \item I loro ruoli
    \item Come collaborano
    \item La distribuzione delle responsabilità
\end{itemize}
\section{Come sono fatti i Design Patterns?}
Un pattern è formato da quattro elementi essenziali:
\begin{itemize}
    \item Il \textbf{nome} del pattern, per riassumere la sua funzionalità in una o due parole
    \item Il \textbf{problema} nel quale il pattern è applicabile. Spiega il problema e il contesto,
    a volte descrive dei problemi specifici del design, mentre a volte può descrivere strutture di
    classi e oggetti.
    \item La \textbf{soluzione} descrive in modo astratto come il pattern risolve il problema
    Descrive gli elementi che compongono il design, le loro responsabilità e le collaborazioni
    \item Le \textbf{conseguenze} portate dall'applicazione del pattern, i costi-benefici
\end{itemize}
\section{Descrizione DP}
Il formato che si sceglie per la descrizione di un pattern non è rilevante, purchè la descrizione
sia completa, coerente e accurata.\\
Di seguito un esempio:
\begin{itemize}
    \item Nome e classificaizone pattern
    \item Sinonimi
    \item Scopo
    \item Motivazione: scenario che illustra un design problem
    \item Applicabilità
    \item Struttura
    \item Partecipanti: classi e oggi inclusi nel pattern
    \item Collaborazioni
    \item Conseguenze
    \item Implementazione
    \item Codice di esempio
    \item Usi noti
    \item Pattern correlati
\end{itemize}
L'obiettivo è sempre quello di aiutare gli sviluppatori a risolvere problemi già
studiati, mostrando che la soluzione descritta è:
\begin{itemize}
    \item Utile
    \item Utilizzabile
    \item Usata
\end{itemize}
\section{Classificazione DP}
\subsection*{Scope}
Un primo criterio riguarda il raggion di azione (scope)
\paragraph*{Classi} Pattern che definiscono le relazioni fra classi e sottoclassi. Le relazioni
sono basate prevalentemente sul concetto di erediterietà e sono quindi statiche.
\paragraph*{Oggetti} Pattern che definiscono relazioni tra oggetti, che possono cambiare durante
l'esecuzione e sono quindi più dinamiche.
\subsection*{Purpose}
Un secondo criterio riguarda lo scopo (purpose):
\begin{itemize}
    \item Creazionali: i pattern di questo tipo sono relativi alle operazioni di creazione oggetti
    \item Strutturali: sono utilizzati per definire la struttura del sistema in termini
    di composizione di classi ed oggetti. Si basano sui concetti OO di ereditarietà e polimorfismo
    \item Comportamentali: permettono di modellare il comportamento del sistema definendo le
    responsabilità delle sue componenti e definendo le modalità di interazione.
\end{itemize}
\subsection{Creational}
Questa categoria raccoglie i pattern che forniscono un'astrazione del processo di
istanziazione degli oggetti. Questi pattern permettono di rendere un sistema
indipendente da come gli oggetti sono creati, rappresentati e composti al suo interno.
\subsection{Structural}
I pattern di questa categoria sono dedicati alla composizione di classi e oggetti per formare
strutture complesse. \'E possibile creare delle classi che ereditano da più classi per
consentire di utilizzare proprietà di più superclassi indipendenti.\\
Particolarmente utili per fare in modo che librerie di classi svilkuppate indipendentemente possano
operare insieme.
\subsection{Behavioral}
Questi pattern sono dedicati all'assegnamento di responsabilità tra gli oggetti e alla
creazione di algoritmi. Una caratteristica comune di questi pattern è data dal supporto
fornito per seguire le comunicazioni che avvengono tra gli oggetti.\\
L'utilizzo di questi pattern permette di dedicarsi principalmente alle connessioni tra
oggetti, tralasciando la gestione dei flussi di controllo.
\section{I Framework}
Un \textbf{Framework} non è una semplice libreria. Un Framework rappresenta il design riusabile di un
sistema (o di una sua parte), definito da un insieme di classi astratte. Un Framework è lo
scheletro di un'applicazione che viene personalizzato da uno sviluppatore. Il programmatore di
applicazioni implementa le interfacce e classi astratte ed ottiene automaticamente la gestione
delle funzionalità richieste.\\
I Framework permettono quindi di definire la struttura e lo scopo di un sistema, si tratta di un buon
esempio di progettazione orientata agli oggetti. Permettono di raggiungere due obiettivi:
\begin{itemize}
    \item Riuso del design
    \item Riuso del codice
\end{itemize}
\paragraph*{Classe Astratta} Una classe astratta è una classe che possiede almeno un metodo non
implementato, definito "astratto". Si tratta di un template per le sottoclassi da cui deriveranno
le specifiche applicazioni.\\
Un Framework è rappresentato da un'insieme di classi astratte e dalle loro interrelazioni. I Design
Pattern sono spesso i mattoni per la costruzione di un Framework.
\section{DP: Adapter (Structural)}
\begin{itemize}
    \item Nome: Adpater
    \item Sinonimo: Wrapper
    \item Scopo: Converte l'interfaccia di una classe in un'altra interfaccia richiesta dal client
    (quindi permette la cooperazione di classi che altrimenti avrebbero interfacce incompatibili)
    \item Motivazione: in alcune circostanze non si può utilizzare una classe già esistente solo
    perchè quest'ultima non comunica più con una interfaccia specializzata richiesta da un'applicazione.
\end{itemize}
Si tratta letteralmente di un adattatore per rendere due compatibili due\\ oggetti che altrimenti
non sarebbero compatibili (come una shuko e una presa italiana).\\
\paragraph*{Partecipanti}
\begin{itemize}
    \item Target: definisce l'interfaccia specializzata del client
    \item Client: collabora con oggetti conformi all'interfaccia target
    \item Adaptee: definisce una interfaccia che deve essere resa conforme
    \item Adaptor: adatta l'interfaccia di Adaptee all'interfaccia Target
\end{itemize}
\paragraph*{Applicabilità}
Adapter può essere utilizzato:
\begin{itemize}
    \item Se si vuole utilizzare una classe esistente la cui interfaccia si incompatibile
    \item Se si vuole creare una classe riusabile che dovrà collaborare con classi non prevedibili
    al momento della sua creazione
    \item Se si vuole riusare un insieme di sottoclassi esistenti, ma non è facile adattare
    l'interfaccia creando una sottoclasse per ciascuna: meglio creare un adattatatore per la classe genitore
\end{itemize}
\paragraph*{Conseguenze sulla classe}
Adapter ridefinisce (overrides) parte del comportamenti di Adaptee.\\
Una clase particolare adatta Adaptee a Target concretizzando un Adapter, quindi non è possibile
adattare una classe e tutte le sue sottoclassi.
\paragraph*{Conseguenze sull'oggetto}
Gli Adapter possono funzionare in molti modi, dalla conversione di interfaccia alla completa
ridefinizione e integrazione dei metodi, la quantità di lavoro svolta da un Adapter dipenderà
da quanto simili sono il Target voluto e l'Adaptee disponibile.
\paragraph*{Pattern correlati}
\begin{itemize}
    \item Bridge
    \item Decorator
    \item Proxy
\end{itemize}
\paragraph*{Correlazione con GRASP} \'E una specie di Indirection e Pure Fabrication, che utilizza Polymorphism.
\section{DP: Strategy (Behavioral)}
\begin{itemize}
    \item Nome: Strategy
    \item Sinonimo: Policy
    \item Scopo: Definisce una famiglia di algoritmi, incapsula ognino in una classe e li rende
    intercambiabili. Permette di variare gli algoritmi indipendentemente dai client che ne fanno uso.
    \item Motivazione: In alcune circostante sono necessari algoritmi diversi in situazioni diverse per
    risolvere lo stesso problema. Per dare più flessibilità all'implementazione, tali algoritmi non
    sono specificati in una sola classe, ma in classi diverse. In questo modo, algoritmi diversi possono
    essere utilizzati in momenti diversi. Inoltre, nuovi algoritmi sono facilemente inseribili.
\end{itemize}
\paragraph*{Partecipanti}
\begin{itemize}
    \item Stretegy (ArrayDisplayFormat): dichiara un'interfaccia comune per tutti gli algoritmi supportati.
    Context utilizza tale interfaccia per invocare gli algoritmi definiti in ogni ConcreteStrategy.
    \item ConcreteStrategy (StandardFormat, MathFormat): implementa l'algoritmo che usa l'interfaccia stretegy
    \item Context (MyArray): è configurata con un oggetto ConcreteStrategy e mantiene un riferimento verso
    questo; può specificare una interfaccia che permette alle Strategy di accedere ai propri dati.
\end{itemize}
\paragraph*{Applicabilità}
\begin{itemize}
    \item Più classi correlate variano soltanto per il loro comportamente. Il pattern permette
    la configurazione di una classe con più comportamenti.
    \item Per modellare la differenza fra diverse varianti dello stesso algoritmo. Esempio:
    calcolo dell'ora per varie zone geografiche
    \item Per nascondere all'utente strutture dati complesse e specifiche dell'algoritmo
    \item Per evitare l'utilizzo di tanti if in un algoritmo. Si crea una classe divers per ogni possibile ramo.
\end{itemize}
\subsection*{Conseguenze}
\paragraph*{Vantaggi}
\begin{itemize}
    \item La definzione di famiglie di algoritmi
    \item Un'alternativa alla gerarchia di classi
    \item Eliminazione di tanti if
    \item Scelta fra varie implementazioni
\end{itemize}
\paragraph*{Svantaggi}
\begin{itemize}
    \item Gli utenti diventano consapevoli dell'esistenza delle strategie
    \item Overhead di comunicazione fra Strategy e Context
    \item Incremento del numero di oggetti
\end{itemize}
\paragraph*{Pattern correlati} Flyweight.
\section{Composite (Structural)}
\paragraph*{Problema} Come comporre oggetti in strutture ad albero?
Utilizzando \textbf{Composite}
\begin{itemize}
    \item Definisce gerarchie di classi
    \item Il Clien tratta foglie e nodi allo stesso modo
    \item L'aggiunta di nuovi tipi di nodi e foglie è molto semplice
\end{itemize}
\subsection*{Descrizione Composite}
\begin{itemize}
    \item Name - Composite
    \item Intent - Comporre oggetti in strutture ad albero per rappresentare gerachie tutto-parti
    trattare uniformemente oggetti individuali e composti, catturare l'essenza ricorsiva della
    composizione
    \item Motivation - In questo modo si semplifica il client dato che si possono trattare
    strutture singole e oggetti in modo uniforme
\end{itemize}
Si rende anche più semplice l'aggiunta di nuove tipologie di componenti (nuove sottoclassi Leaf
o Composite potranno essere utilizzate automaticamente nelle strutture esistenti e operre con il
codice dei client). Può rendere il progetto troppo generico per la facile aggiunta di nuove
componenti.
\section{DP: Singleton (Creational)}
\paragraph*{Problema} Assicurare che una classe abbia una sola istanza con accesso
globale. \\
Per esempio voglio utilizzare un'unica connessione verso il database ed impedire che un oggetto
possa autonomamente creane di nuove.
\paragraph*{Soluzione} Definire un metodo statico della classe che restituisce il singleton.
\subsection*{Conseguenze}
\paragraph*{Pro}
\begin{itemize}
    \item Accesso controllato ad un'unica istanza
    \item Incapsula la creazione dell'oggetto
    \item In alcune implementazioni possiamo gestire un pool di istanze invece che una singola
    istanza
\end{itemize}
\paragraph*{Contro}
\begin{itemize}
    \item In alcune implementazioni ogni volta che l'oggetto viene richiesto viene anche
    controllata la sua esistenza
    \item Singleton non tratta distruzione dell'oggetto
\end{itemize}
\section{DP: Facade (Structural)}
\paragraph*{Problema} Un client accede direttamente a numerose classi che fanno parte di un altro
modulo. \\
Il pattern Facade nasconde ai client il sottosistema. Questo risulta molto utile per migliorare
l'integrazione fra componenti. Questo pattern ha lo scopo di fornire un'intefaccia unificata per
un dato insieme di interfacce presenti in un sottosistema.
\paragraph*{Applicabilità}
Per ottenere interfacce semplici per sottosistemi complessi o per i casi in cui vi sono
troppe dipendenze fra i client e le classi. \\
Per ottenere una struttura a livelli in cui il Facade funge da entrata e uscita di ogni
livello.
\subsection*{Partecipanti}
\begin{itemize}
    \item Facade: Conosce la struttura del sottosistema e delega agli oggetti interni più
    appropriati le richieste provenienti dall'esterno.
    \item Classi di Subsystem: Forniscono le funzionalità interne adatte a rispondere alle richieste
    provenienti da Facade. Esse non hanno conoscenza dell'esistenza di Facade e non dipendono da esso.
\end{itemize}
\subsection*{Conseguenze}
La classe Facade nasconde il sottosistema al Client, la complessità del sottosistema viene
spostata all'interno della classe Facade. Si disaccoppia il codice del Client dagli oggetti
che si trovano dietro la Facade (Low coupling pattern GRASP).\\
Risulta inoltre più facile modifica il sottosistema.
\paragraph*{Vantaggi}
\begin{itemize}
    \item Nasconde ai client i componenti del sottosistema, riducendone così la complessità
    \item Consente di modificare i componenti del sottosistema senza il coinvolgimento del client
\end{itemize}
Il Facade si interpone tra classi client e il sottosistema fungendo da intermediario fra queste 2 entità.
(Indirection e Protected Variations).
\subsection*{Alcuni usi noti}
Java Virtual Machine e varie librerie standard come AWT e Swing, forniscono un seti di
wrapper Facade che incapsulano molte delle chiamate native di basso livello del SO e GUI APIs. \\
Il pattern Facade è spesso usato anche per fornire un'interfaccia unificata per un insieme di funzionalità
che altrimenti andrebbero ad appesantire il client. Si nascondono inoltre le ie complessità delle
interazioni e delle dipendenze.
\section{DP: Observer (Behavioral)}
Il pattern Observer definisce una relazione uno-a-molti tra oggetti in modo che quando un oggetto
cambia stato, tutti gli oggetti che dipendono da esso siano notificati e aggiornati automaticamente.\\
In pratica si definisce uno schema 1:N fra due oggetti chiamati Observer e Subject: i primi
osservano un evento specifico del soggetto e non appena quest'ultimo lo genera gli osservatori
vengono informati del cmabiamento di stato e aggiornano automaticamente le informazioni.
\subsection*{Applicabilità}
Il design Observr è indicato in particolare:
\begin{itemize}
    \item Quando un'astrazione ha due aspetti, uno dipendente dall'altro. Implementare questi
    aspetti in oggetti separati permette al programmatore di modificarli e di riutilizzarli
    indipendentemente
    \item Quando il cambiamento di stato di un oggetti implica il cambiamento di stati di altri oggetti
    e non è noto in anticipo il numero degli oggetti che dovranno essere cambiati
    \item Quando un oggetto deve essere in gradi di notificar eil proprio cambiamento di stato
    ad altri oggetti senza conoscere quali siano tali oggetti
\end{itemize}
\subsection*{Partecipanti}
\begin{itemize}
    \item Subject \begin{itemize}
        \item Conosce i suoi osservatori che possono essere in un numero indefinito
        \item Fornisce un'interfaccia per aggiungere o eliminare oggetti Observer
    \end{itemize}
    \item Observer \begin{itemize}
        \item Definisce un'interfaccia di aggiornamento che deve essere avvisata dei cambiamenti di
        un Subject
    \end{itemize}
    \item ConcreteObserver \begin{itemize}
        \item Fa riferimento a un oggetto ConcreteSbject
        \item Il suo stato deve restare coerente con quello del soggetto
        \item Implementa l'interfaccia per l'aggiornamento della classe Observer per
        mantenere il suo stato coerente con quello del soggetto
    \end{itemize}
    \item ConcreteSubject \begin{itemize}
        \item Contiene valori di interesse per gli oggetti ConcreteObserver
        \item Invia un avviso ai suoi osservatori quando il suo stato cambia
    \end{itemize}
\end{itemize}
\subsection*{Conseguenze}
Il pattern Observer permette di variare i Subject e gli Observer indipendentemente, è 
possibile riutilizzare i soggetti senza il riutilizzo dei loro osservatori e viceversa.\\
Inoltre: 
\begin{itemize}
    \item Astrazione della relazione esistente tra Subject e Observer: il soggetto infatti sa
    soltano id avere una lista di osservatori, ognuno derivato dalla semplice interfaccia della classe
    astratta Observer.
    \item Supporto per comunicazioni in broadcast: a differenza di una normale richiesta, la notifica
    di cambiamento inviata da un soggetto non ha bisogno di specificare il proprio destinatario.
    La notifica è trasmessa automaticamente a tutti gli osservatori interessati.
    \item Update imprevisti: dal momento che gli osservatori non sono a conoscenza della presenza
    degli altri osservatori, una apparentemente innocua operazione sul soggetto può provocare una
    cascata di aggiornamenti degli osservatori e dei loro oggetti dipendenti. Questo problema è aggravato
    dal fatto che la semplice operazione di notifica definita nel DP non prevede dettagli su
    cosa è cambiato nel soggetto.
\end{itemize}
\subsection*{Pattern correlati}
\begin{itemize}
    \item Mediator: definisce un oggetto che incapsula il modo in cu un insieme di oggetti
    intergiscono mantenendo la loro indipendenza
    \item Singleton: si assicura del fatto che una classe abbia una sola istanza e fornisce un
    punto di accesso globale ad essa
\end{itemize}
\section{Factory Method (Creational)}
\begin{itemize}
    \item Nome - Factory Method
    \item Altri nomi: Virtual Constructor
    \item Classificazione - Creational
    \item Scopo - Definire un'interfaccia per la creazione di un oggetto, lasciando alle sottoclassi 
    la decisione su quale classe istanziare. Il Factory Method permette di posticipare l'istanziazione
    e permetterla a runtime
    \item Motivazione - Si vuole che un oggetto istanzi un altro oggetto, ma non si sa a priori quale
    tipo di oggetto deve essere creato.
\end{itemize}
Si tratta di un pattern ampiamente usato nei Framework dove le classi astratte definiscono le relazioni
tra gli elementi del dominio e sono responsabili per la creazione degli oggetti concreti.
\subsection*{Applicabilità}
Il Factory Method è applicabile quando:
\begin{itemize}
    \item Una classe non può prevedere il tipo di oggetti che deve creare
    \item Una classe vuole che siano le sue sottoclassi a specificare gli oggetti che crea
    \item Si vuole conoscere la classe alla quale è stata delegata la reponsabilità della creazione
\end{itemize}
La classe \textbf{Creator} affida alle sue sottoclassi la definizione del Factory Method in modo
da ritornare l'istanza appropriata del ConcreteProduct
\subsection*{Conseguenze}
Utlizzare un metodo Factory per la creazione di oggetti in una classe fornisce sempre una
flessibilità maggiore rispetto alla creazione diretta dell'oggetto. Fornisce inoltre alle sottoclassi
un punto di aggancio per la produzione di una versione specializzata di un oggetto.
\section{Problemi di progettazione}
Per utilizzare i pattern nel vostro progetto è necessario tenere in mente che qualsiasi problema di 
progettazione che si sta affrontando può avere un pattern associato che può essere applicato.
\begin{itemize}
    \item Dire a diversi oggetti che lo stato di qualche altro oggetto è cambiato (pattern Observer)
    \item Mettere in ordine le interfacce con un numero di oggetti correlati che spesso devono essere
    sviluppati in modo incrementale (pattern Facade)
\end{itemize}
\section{Pattern Dati}
Pattern per la manipolazione di dati di DBMS, noi trattaremo il modello relazionale dato
che è il più diffuso a livello commerciale. L'esigenza di definire dei pattern per questa casistica
deriva dal fatto che i modelli ER e i modello OO (Object Oriented) sono strutturalmente molto diversi.
\subsection{Active Record}
Adatto nel caso in cui i record del DB corrispondono alle entità usate nella logica di business.
Un Active Record include la parte della logica applicativa.\\
In applicazioni semplici si ha una classe di dominio per una tabella del database e quindi ogni
oggetto di dominio è responsabile di caricare e salvare nel database (le classi corrispondono alle struttura
dei record nel db-schema isomorfico, cioè alle tabelle). Un oggetto incapsula dati e comportamento
la maggior parte dei dati sono persistenti e devono essere memorizzati in un DB.\\
Active Record usa l'approccio più ovvio: mettere la logica di accesso ai dati nell'oggetto di dominio:
in questo modo tutti conoscono come leggere e scrivere i dati a/dal DB.
\paragraph*{Classificazione tipica dei metodi}
\begin{itemize}
    \item Load \begin{itemize}
        \item Costruzione di un'istanza dell'oggetto a partire dai risultati ritornati dalle query SQL
        \item Se non costruiamo interamento l'oggeto al primo caricamento i metodi devono caricare le istanze
        quando necessario (lazy-load)
        \item Nel caso di riferimenti ad oggetti può essere necessario caricare altri oggetti e quindi navigare
        altre tabelle.
    \end{itemize}
    \item Costruttuore classico - Costuire nuove istanze da inserire successivamente nel DB
    \item Metodi finder (statici) - Incapsulano le Query SQL e ritornano istanze degli oggetti
    \item Metodi di aggiornamento del DB \begin{itemize}
        \item Update, aggiorna un record esistente con i valori degli attributi
        \item Insert, aggiunge un record utilizzando i valori degli attributi
        \item Delete, elimina il record corrispondente all'oggetto corrente
    \end{itemize}
    \item Metodi accessors - Classici set e get per accedere ai campi
    \item Metodi di logica di business
\end{itemize}
\paragraph*{Vantaggi}
\begin{itemize}
    \item Semplicità implementativa e d'uso nel caso di logica di business OO
\end{itemize}
\paragraph*{Svantaggi}
\begin{itemize}
    \item L'acoppiamento fra logica applicativa e DB rende difficile il refactoring separato
    dei due progetti (progetto applicazion e del DB). Ci sono modi di realizzare il mapping su DB
    che disaccoppiano maggiormente la logica applicativa e meccanismi di persistenza
    \item Forza o quasi l'isomorfismo fra schema del DB e entità dle modello OO
\end{itemize}
\subsection{Data Mapper}
Consiste in uno strato separato di componenti dedicati a trasferire i dati fra applicazione e DB.
\begin{itemize}
    \item Tratta indipendentemente i due schemi, tenendo opportunamente conto delle differenze
    \item Bussiness logic non deve conoscere l'esistenza del DB
    \item Nessuna interfaccia SQL nel programma
    \item Nessuna conoscenza dello schema del DB
    \item Inverte le dipendenze rispetto agli altri gateway
    \item Generlalmente coinvolce altri design pattern per la gesitone della sincronizzazione 
    fra i due schemi
\end{itemize}
\paragraph*{Quando usarlo} Imprescindibile per gestire un mapping complesso fra DB e logica business.
\paragraph*{Vantaggi}
\begin{itemize}
    \item Isola i due strati (logica di business e DB mapping)
    \item La logica di business non usa le API SQL
    \item La logica di business non dipende da alcuna conoscenza del DB
    \item La logica di business non deve gestire la sincronizzazione dei dati persistenti
    \item Il layter Data Mapper può essere sostituito intergralmente senza bisogno di modificare
    alcun dettaglio dello strato applicativo (es. se cambio il DB, il modello dell'applicazione o per test)
\end{itemize}
\paragraph*{Svantaggi}
Difficoltà implementiativa.